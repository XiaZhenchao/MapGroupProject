{"ast":null,"code":"var toGeoJSON = function () {\n  'use strict';\n\n  var removeSpace = /\\s*/g,\n    trimSpace = /^\\s*|\\s*$/g,\n    splitSpace = /\\s+/;\n  // generate a short, numeric hash of a string\n  function okhash(x) {\n    if (!x || !x.length) return 0;\n    for (var i = 0, h = 0; i < x.length; i++) {\n      h = (h << 5) - h + x.charCodeAt(i) | 0;\n    }\n    return h;\n  }\n  // all Y children of X\n  function get(x, y) {\n    return x.getElementsByTagName(y);\n  }\n  function attr(x, y) {\n    return x.getAttribute(y);\n  }\n  function attrf(x, y) {\n    return parseFloat(attr(x, y));\n  }\n  // one Y child of X, if any, otherwise null\n  function get1(x, y) {\n    var n = get(x, y);\n    return n.length ? n[0] : null;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n  function norm(el) {\n    if (el.normalize) {\n      el.normalize();\n    }\n    return el;\n  }\n  // cast array x into numbers\n  function numarray(x) {\n    for (var j = 0, o = []; j < x.length; j++) {\n      o[j] = parseFloat(x[j]);\n    }\n    return o;\n  }\n  function clean(x) {\n    var o = {};\n    for (var i in x) {\n      if (x[i]) {\n        o[i] = x[i];\n      }\n    }\n    return o;\n  }\n  // get the content of a text node, if any\n  function nodeVal(x) {\n    if (x) {\n      norm(x);\n    }\n    return x && x.textContent || '';\n  }\n  // get one coordinate from a coordinate array, if any\n  function coord1(v) {\n    return numarray(v.replace(removeSpace, '').split(','));\n  }\n  // get all coordinates from a coordinate array as [[],[]]\n  function coord(v) {\n    var coords = v.replace(trimSpace, '').split(splitSpace),\n      o = [];\n    for (var i = 0; i < coords.length; i++) {\n      o.push(coord1(coords[i]));\n    }\n    return o;\n  }\n  function coordPair(x) {\n    var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n      ele = get1(x, 'ele'),\n      // handle namespaced attribute in browser\n      heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n      time = get1(x, 'time'),\n      e;\n    if (ele) {\n      e = parseFloat(nodeVal(ele));\n      if (!isNaN(e)) {\n        ll.push(e);\n      }\n    }\n    return {\n      coordinates: ll,\n      time: time ? nodeVal(time) : null,\n      heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n    };\n  }\n\n  // create a new feature collection parent object\n  function fc() {\n    return {\n      type: 'FeatureCollection',\n      features: []\n    };\n  }\n  var serializer;\n  if (typeof XMLSerializer !== 'undefined') {\n    /* istanbul ignore next */\n    serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n  } else if (typeof exports === 'object' && typeof process === 'object' && !process.browser) {\n    serializer = new (require('xmldom').XMLSerializer)();\n  }\n  function xml2str(str) {\n    // IE9 will create a new XMLSerializer but it'll crash immediately.\n    // This line is ignored because we don't run coverage tests in IE9\n    /* istanbul ignore next */\n    if (str.xml !== undefined) return str.xml;\n    return serializer.serializeToString(str);\n  }\n  var t = {\n    kml: function (doc) {\n      var gj = fc(),\n        // styleindex keeps track of hashed styles in order to match features\n        styleIndex = {},\n        // atomic geospatial types supported by KML - MultiGeometry is\n        // handled separately\n        geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n        // all root placemarks in the file\n        placemarks = get(doc, 'Placemark'),\n        styles = get(doc, 'Style'),\n        styleMaps = get(doc, 'StyleMap');\n      for (var k = 0; k < styles.length; k++) {\n        styleIndex['#' + attr(styles[k], 'id')] = okhash(xml2str(styles[k])).toString(16);\n      }\n      for (var l = 0; l < styleMaps.length; l++) {\n        styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n      }\n      for (var j = 0; j < placemarks.length; j++) {\n        gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n      }\n      function kmlColor(v) {\n        var color, opacity;\n        v = v || '';\n        if (v.substr(0, 1) === '#') {\n          v = v.substr(1);\n        }\n        if (v.length === 6 || v.length === 3) {\n          color = v;\n        }\n        if (v.length === 8) {\n          opacity = parseInt(v.substr(0, 2), 16) / 255;\n          color = '#' + v.substr(2);\n        }\n        return [color, isNaN(opacity) ? undefined : opacity];\n      }\n      function gxCoord(v) {\n        return numarray(v.split(' '));\n      }\n      function gxCoords(root) {\n        var elems = get(root, 'coord', 'gx'),\n          coords = [],\n          times = [];\n        if (elems.length === 0) elems = get(root, 'gx:coord');\n        for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n        var timeElems = get(root, 'when');\n        for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n        return {\n          coords: coords,\n          times: times\n        };\n      }\n      function getGeometry(root) {\n        var geomNode,\n          geomNodes,\n          i,\n          j,\n          k,\n          geoms = [],\n          coordTimes = [];\n        if (get1(root, 'MultiGeometry')) {\n          return getGeometry(get1(root, 'MultiGeometry'));\n        }\n        if (get1(root, 'MultiTrack')) {\n          return getGeometry(get1(root, 'MultiTrack'));\n        }\n        if (get1(root, 'gx:MultiTrack')) {\n          return getGeometry(get1(root, 'gx:MultiTrack'));\n        }\n        for (i = 0; i < geotypes.length; i++) {\n          geomNodes = get(root, geotypes[i]);\n          if (geomNodes) {\n            for (j = 0; j < geomNodes.length; j++) {\n              geomNode = geomNodes[j];\n              if (geotypes[i] === 'Point') {\n                geoms.push({\n                  type: 'Point',\n                  coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                });\n              } else if (geotypes[i] === 'LineString') {\n                geoms.push({\n                  type: 'LineString',\n                  coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                });\n              } else if (geotypes[i] === 'Polygon') {\n                var rings = get(geomNode, 'LinearRing'),\n                  coords = [];\n                for (k = 0; k < rings.length; k++) {\n                  coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                }\n                geoms.push({\n                  type: 'Polygon',\n                  coordinates: coords\n                });\n              } else if (geotypes[i] === 'Track' || geotypes[i] === 'gx:Track') {\n                var track = gxCoords(geomNode);\n                geoms.push({\n                  type: 'LineString',\n                  coordinates: track.coords\n                });\n                if (track.times.length) coordTimes.push(track.times);\n              }\n            }\n          }\n        }\n        return {\n          geoms: geoms,\n          coordTimes: coordTimes\n        };\n      }\n      function getPlacemark(root) {\n        var geomsAndTimes = getGeometry(root),\n          i,\n          properties = {},\n          name = nodeVal(get1(root, 'name')),\n          styleUrl = nodeVal(get1(root, 'styleUrl')),\n          description = nodeVal(get1(root, 'description')),\n          timeSpan = get1(root, 'TimeSpan'),\n          extendedData = get1(root, 'ExtendedData'),\n          lineStyle = get1(root, 'LineStyle'),\n          polyStyle = get1(root, 'PolyStyle');\n        if (!geomsAndTimes.geoms.length) return [];\n        if (name) properties.name = name;\n        if (styleUrl[0] !== '#') {\n          styleUrl = '#' + styleUrl;\n        }\n        if (styleUrl && styleIndex[styleUrl]) {\n          properties.styleUrl = styleUrl;\n          properties.styleHash = styleIndex[styleUrl];\n        }\n        if (description) properties.description = description;\n        if (timeSpan) {\n          var begin = nodeVal(get1(timeSpan, 'begin'));\n          var end = nodeVal(get1(timeSpan, 'end'));\n          properties.timespan = {\n            begin: begin,\n            end: end\n          };\n        }\n        if (lineStyle) {\n          var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n            color = linestyles[0],\n            opacity = linestyles[1],\n            width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n          if (color) properties.stroke = color;\n          if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n          if (!isNaN(width)) properties['stroke-width'] = width;\n        }\n        if (polyStyle) {\n          var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n            pcolor = polystyles[0],\n            popacity = polystyles[1],\n            fill = nodeVal(get1(polyStyle, 'fill')),\n            outline = nodeVal(get1(polyStyle, 'outline'));\n          if (pcolor) properties.fill = pcolor;\n          if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n          if (fill) properties['fill-opacity'] = fill === '1' ? 1 : 0;\n          if (outline) properties['stroke-opacity'] = outline === '1' ? 1 : 0;\n        }\n        if (extendedData) {\n          var datas = get(extendedData, 'Data'),\n            simpleDatas = get(extendedData, 'SimpleData');\n          for (i = 0; i < datas.length; i++) {\n            properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n          }\n          for (i = 0; i < simpleDatas.length; i++) {\n            properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n          }\n        }\n        if (geomsAndTimes.coordTimes.length) {\n          properties.coordTimes = geomsAndTimes.coordTimes.length === 1 ? geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n        }\n        var feature = {\n          type: 'Feature',\n          geometry: geomsAndTimes.geoms.length === 1 ? geomsAndTimes.geoms[0] : {\n            type: 'GeometryCollection',\n            geometries: geomsAndTimes.geoms\n          },\n          properties: properties\n        };\n        if (attr(root, 'id')) feature.id = attr(root, 'id');\n        return [feature];\n      }\n      return gj;\n    },\n    gpx: function (doc) {\n      var i,\n        tracks = get(doc, 'trk'),\n        routes = get(doc, 'rte'),\n        waypoints = get(doc, 'wpt'),\n        // a feature collection\n        gj = fc(),\n        feature;\n      for (i = 0; i < tracks.length; i++) {\n        feature = getTrack(tracks[i]);\n        if (feature) gj.features.push(feature);\n      }\n      for (i = 0; i < routes.length; i++) {\n        feature = getRoute(routes[i]);\n        if (feature) gj.features.push(feature);\n      }\n      for (i = 0; i < waypoints.length; i++) {\n        gj.features.push(getPoint(waypoints[i]));\n      }\n      function getPoints(node, pointname) {\n        var pts = get(node, pointname),\n          line = [],\n          times = [],\n          heartRates = [],\n          l = pts.length;\n        if (l < 2) return {}; // Invalid line in GeoJSON\n        for (var i = 0; i < l; i++) {\n          var c = coordPair(pts[i]);\n          line.push(c.coordinates);\n          if (c.time) times.push(c.time);\n          if (c.heartRate) heartRates.push(c.heartRate);\n        }\n        return {\n          line: line,\n          times: times,\n          heartRates: heartRates\n        };\n      }\n      function getTrack(node) {\n        var segments = get(node, 'trkseg'),\n          track = [],\n          times = [],\n          heartRates = [],\n          line;\n        for (var i = 0; i < segments.length; i++) {\n          line = getPoints(segments[i], 'trkpt');\n          if (line.line) track.push(line.line);\n          if (line.times && line.times.length) times.push(line.times);\n          if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n        }\n        if (track.length === 0) return;\n        var properties = getProperties(node);\n        if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n        if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n        return {\n          type: 'Feature',\n          properties: properties,\n          geometry: {\n            type: track.length === 1 ? 'LineString' : 'MultiLineString',\n            coordinates: track.length === 1 ? track[0] : track\n          }\n        };\n      }\n      function getRoute(node) {\n        var line = getPoints(node, 'rtept');\n        if (!line.line) return;\n        var routeObj = {\n          type: 'Feature',\n          properties: getProperties(node),\n          geometry: {\n            type: 'LineString',\n            coordinates: line.line\n          }\n        };\n        return routeObj;\n      }\n      function getPoint(node) {\n        var prop = getProperties(node);\n        prop.sym = nodeVal(get1(node, 'sym'));\n        return {\n          type: 'Feature',\n          properties: prop,\n          geometry: {\n            type: 'Point',\n            coordinates: coordPair(node).coordinates\n          }\n        };\n      }\n      function getProperties(node) {\n        var meta = ['name', 'desc', 'author', 'copyright', 'link', 'time', 'keywords'],\n          prop = {},\n          k;\n        for (k = 0; k < meta.length; k++) {\n          prop[meta[k]] = nodeVal(get1(node, meta[k]));\n        }\n        return clean(prop);\n      }\n      return gj;\n    }\n  };\n  return t;\n}();\nif (typeof module !== 'undefined') module.exports = toGeoJSON;","map":{"version":3,"names":["toGeoJSON","removeSpace","trimSpace","splitSpace","okhash","x","length","i","h","charCodeAt","get","y","getElementsByTagName","attr","getAttribute","attrf","parseFloat","get1","n","norm","el","normalize","numarray","j","o","clean","nodeVal","textContent","coord1","v","replace","split","coord","coords","push","coordPair","ll","ele","heartRate","time","e","isNaN","coordinates","fc","type","features","serializer","XMLSerializer","exports","process","browser","require","xml2str","str","xml","undefined","serializeToString","t","kml","doc","gj","styleIndex","geotypes","placemarks","styles","styleMaps","k","toString","l","concat","getPlacemark","kmlColor","color","opacity","substr","parseInt","gxCoord","gxCoords","root","elems","times","timeElems","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","track","geomsAndTimes","properties","name","styleUrl","description","timeSpan","extendedData","lineStyle","polyStyle","styleHash","begin","end","timespan","linestyles","width","stroke","polystyles","pcolor","popacity","fill","outline","datas","simpleDatas","feature","geometry","geometries","id","gpx","tracks","routes","waypoints","getTrack","getRoute","getPoint","getPoints","node","pointname","pts","line","heartRates","c","segments","getProperties","routeObj","prop","sym","meta","module"],"sources":["C:/Users/haosh/Desktop/CSE416 projec/MapGroupProject/node_modules/togeojson/togeojson.js"],"sourcesContent":["var toGeoJSON = (function() {\n    'use strict';\n\n    var removeSpace = (/\\s*/g),\n        trimSpace = (/^\\s*|\\s*$/g),\n        splitSpace = (/\\s+/);\n    // generate a short, numeric hash of a string\n    function okhash(x) {\n        if (!x || !x.length) return 0;\n        for (var i = 0, h = 0; i < x.length; i++) {\n            h = ((h << 5) - h) + x.charCodeAt(i) | 0;\n        } return h;\n    }\n    // all Y children of X\n    function get(x, y) { return x.getElementsByTagName(y); }\n    function attr(x, y) { return x.getAttribute(y); }\n    function attrf(x, y) { return parseFloat(attr(x, y)); }\n    // one Y child of X, if any, otherwise null\n    function get1(x, y) { var n = get(x, y); return n.length ? n[0] : null; }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n    function norm(el) { if (el.normalize) { el.normalize(); } return el; }\n    // cast array x into numbers\n    function numarray(x) {\n        for (var j = 0, o = []; j < x.length; j++) { o[j] = parseFloat(x[j]); }\n        return o;\n    }\n    function clean(x) {\n        var o = {};\n        for (var i in x) { if (x[i]) { o[i] = x[i]; } }\n        return o;\n    }\n    // get the content of a text node, if any\n    function nodeVal(x) {\n        if (x) { norm(x); }\n        return (x && x.textContent) || '';\n    }\n    // get one coordinate from a coordinate array, if any\n    function coord1(v) { return numarray(v.replace(removeSpace, '').split(',')); }\n    // get all coordinates from a coordinate array as [[],[]]\n    function coord(v) {\n        var coords = v.replace(trimSpace, '').split(splitSpace),\n            o = [];\n        for (var i = 0; i < coords.length; i++) {\n            o.push(coord1(coords[i]));\n        }\n        return o;\n    }\n    function coordPair(x) {\n        var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n            ele = get1(x, 'ele'),\n            // handle namespaced attribute in browser\n            heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n            time = get1(x, 'time'),\n            e;\n        if (ele) {\n            e = parseFloat(nodeVal(ele));\n            if (!isNaN(e)) {\n                ll.push(e);\n            }\n        }\n        return {\n            coordinates: ll,\n            time: time ? nodeVal(time) : null,\n            heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n        };\n    }\n\n    // create a new feature collection parent object\n    function fc() {\n        return {\n            type: 'FeatureCollection',\n            features: []\n        };\n    }\n\n    var serializer;\n    if (typeof XMLSerializer !== 'undefined') {\n        /* istanbul ignore next */\n        serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n    } else if (typeof exports === 'object' && typeof process === 'object' && !process.browser) {\n        serializer = new (require('xmldom').XMLSerializer)();\n    }\n    function xml2str(str) {\n        // IE9 will create a new XMLSerializer but it'll crash immediately.\n        // This line is ignored because we don't run coverage tests in IE9\n        /* istanbul ignore next */\n        if (str.xml !== undefined) return str.xml;\n        return serializer.serializeToString(str);\n    }\n\n    var t = {\n        kml: function(doc) {\n\n            var gj = fc(),\n                // styleindex keeps track of hashed styles in order to match features\n                styleIndex = {},\n                // atomic geospatial types supported by KML - MultiGeometry is\n                // handled separately\n                geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n                // all root placemarks in the file\n                placemarks = get(doc, 'Placemark'),\n                styles = get(doc, 'Style'),\n                styleMaps = get(doc, 'StyleMap');\n\n            for (var k = 0; k < styles.length; k++) {\n                styleIndex['#' + attr(styles[k], 'id')] = okhash(xml2str(styles[k])).toString(16);\n            }\n            for (var l = 0; l < styleMaps.length; l++) {\n                styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n            }\n            for (var j = 0; j < placemarks.length; j++) {\n                gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n            }\n            function kmlColor(v) {\n                var color, opacity;\n                v = v || '';\n                if (v.substr(0, 1) === '#') { v = v.substr(1); }\n                if (v.length === 6 || v.length === 3) { color = v; }\n                if (v.length === 8) {\n                    opacity = parseInt(v.substr(0, 2), 16) / 255;\n                    color = '#'+v.substr(2);\n                }\n                return [color, isNaN(opacity) ? undefined : opacity];\n            }\n            function gxCoord(v) { return numarray(v.split(' ')); }\n            function gxCoords(root) {\n                var elems = get(root, 'coord', 'gx'), coords = [], times = [];\n                if (elems.length === 0) elems = get(root, 'gx:coord');\n                for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n                var timeElems = get(root, 'when');\n                for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n                return {\n                    coords: coords,\n                    times: times\n                };\n            }\n            function getGeometry(root) {\n                var geomNode, geomNodes, i, j, k, geoms = [], coordTimes = [];\n                if (get1(root, 'MultiGeometry')) { return getGeometry(get1(root, 'MultiGeometry')); }\n                if (get1(root, 'MultiTrack')) { return getGeometry(get1(root, 'MultiTrack')); }\n                if (get1(root, 'gx:MultiTrack')) { return getGeometry(get1(root, 'gx:MultiTrack')); }\n                for (i = 0; i < geotypes.length; i++) {\n                    geomNodes = get(root, geotypes[i]);\n                    if (geomNodes) {\n                        for (j = 0; j < geomNodes.length; j++) {\n                            geomNode = geomNodes[j];\n                            if (geotypes[i] === 'Point') {\n                                geoms.push({\n                                    type: 'Point',\n                                    coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'LineString') {\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'Polygon') {\n                                var rings = get(geomNode, 'LinearRing'),\n                                    coords = [];\n                                for (k = 0; k < rings.length; k++) {\n                                    coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                                }\n                                geoms.push({\n                                    type: 'Polygon',\n                                    coordinates: coords\n                                });\n                            } else if (geotypes[i] === 'Track' ||\n                                geotypes[i] === 'gx:Track') {\n                                var track = gxCoords(geomNode);\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: track.coords\n                                });\n                                if (track.times.length) coordTimes.push(track.times);\n                            }\n                        }\n                    }\n                }\n                return {\n                    geoms: geoms,\n                    coordTimes: coordTimes\n                };\n            }\n            function getPlacemark(root) {\n                var geomsAndTimes = getGeometry(root), i, properties = {},\n                    name = nodeVal(get1(root, 'name')),\n                    styleUrl = nodeVal(get1(root, 'styleUrl')),\n                    description = nodeVal(get1(root, 'description')),\n                    timeSpan = get1(root, 'TimeSpan'),\n                    extendedData = get1(root, 'ExtendedData'),\n                    lineStyle = get1(root, 'LineStyle'),\n                    polyStyle = get1(root, 'PolyStyle');\n\n                if (!geomsAndTimes.geoms.length) return [];\n                if (name) properties.name = name;\n                if (styleUrl[0] !== '#') {\n                    styleUrl = '#' + styleUrl;\n                }\n                if (styleUrl && styleIndex[styleUrl]) {\n                    properties.styleUrl = styleUrl;\n                    properties.styleHash = styleIndex[styleUrl];\n                }\n                if (description) properties.description = description;\n                if (timeSpan) {\n                    var begin = nodeVal(get1(timeSpan, 'begin'));\n                    var end = nodeVal(get1(timeSpan, 'end'));\n                    properties.timespan = { begin: begin, end: end };\n                }\n                if (lineStyle) {\n                    var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n                        color = linestyles[0],\n                        opacity = linestyles[1],\n                        width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                    if (color) properties.stroke = color;\n                    if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n                    if (!isNaN(width)) properties['stroke-width'] = width;\n                }\n                if (polyStyle) {\n                    var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n                        pcolor = polystyles[0],\n                        popacity = polystyles[1],\n                        fill = nodeVal(get1(polyStyle, 'fill')),\n                        outline = nodeVal(get1(polyStyle, 'outline'));\n                    if (pcolor) properties.fill = pcolor;\n                    if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n                    if (fill) properties['fill-opacity'] = fill === '1' ? 1 : 0;\n                    if (outline) properties['stroke-opacity'] = outline === '1' ? 1 : 0;\n                }\n                if (extendedData) {\n                    var datas = get(extendedData, 'Data'),\n                        simpleDatas = get(extendedData, 'SimpleData');\n\n                    for (i = 0; i < datas.length; i++) {\n                        properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n                    }\n                    for (i = 0; i < simpleDatas.length; i++) {\n                        properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n                    }\n                }\n                if (geomsAndTimes.coordTimes.length) {\n                    properties.coordTimes = (geomsAndTimes.coordTimes.length === 1) ?\n                        geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n                }\n                var feature = {\n                    type: 'Feature',\n                    geometry: (geomsAndTimes.geoms.length === 1) ? geomsAndTimes.geoms[0] : {\n                        type: 'GeometryCollection',\n                        geometries: geomsAndTimes.geoms\n                    },\n                    properties: properties\n                };\n                if (attr(root, 'id')) feature.id = attr(root, 'id');\n                return [feature];\n            }\n            return gj;\n        },\n        gpx: function(doc) {\n            var i,\n                tracks = get(doc, 'trk'),\n                routes = get(doc, 'rte'),\n                waypoints = get(doc, 'wpt'),\n                // a feature collection\n                gj = fc(),\n                feature;\n            for (i = 0; i < tracks.length; i++) {\n                feature = getTrack(tracks[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < routes.length; i++) {\n                feature = getRoute(routes[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < waypoints.length; i++) {\n                gj.features.push(getPoint(waypoints[i]));\n            }\n            function getPoints(node, pointname) {\n                var pts = get(node, pointname),\n                    line = [],\n                    times = [],\n                    heartRates = [],\n                    l = pts.length;\n                if (l < 2) return {};  // Invalid line in GeoJSON\n                for (var i = 0; i < l; i++) {\n                    var c = coordPair(pts[i]);\n                    line.push(c.coordinates);\n                    if (c.time) times.push(c.time);\n                    if (c.heartRate) heartRates.push(c.heartRate);\n                }\n                return {\n                    line: line,\n                    times: times,\n                    heartRates: heartRates\n                };\n            }\n            function getTrack(node) {\n                var segments = get(node, 'trkseg'),\n                    track = [],\n                    times = [],\n                    heartRates = [],\n                    line;\n                for (var i = 0; i < segments.length; i++) {\n                    line = getPoints(segments[i], 'trkpt');\n                    if (line.line) track.push(line.line);\n                    if (line.times && line.times.length) times.push(line.times);\n                    if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n                }\n                if (track.length === 0) return;\n                var properties = getProperties(node);\n                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n                return {\n                    type: 'Feature',\n                    properties: properties,\n                    geometry: {\n                        type: track.length === 1 ? 'LineString' : 'MultiLineString',\n                        coordinates: track.length === 1 ? track[0] : track\n                    }\n                };\n            }\n            function getRoute(node) {\n                var line = getPoints(node, 'rtept');\n                if (!line.line) return;\n                var routeObj = {\n                    type: 'Feature',\n                    properties: getProperties(node),\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: line.line\n                    }\n                };\n                return routeObj;\n            }\n            function getPoint(node) {\n                var prop = getProperties(node);\n                prop.sym = nodeVal(get1(node, 'sym'));\n                return {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'Point',\n                        coordinates: coordPair(node).coordinates\n                    }\n                };\n            }\n            function getProperties(node) {\n                var meta = ['name', 'desc', 'author', 'copyright', 'link',\n                            'time', 'keywords'],\n                    prop = {},\n                    k;\n                for (k = 0; k < meta.length; k++) {\n                    prop[meta[k]] = nodeVal(get1(node, meta[k]));\n                }\n                return clean(prop);\n            }\n            return gj;\n        }\n    };\n    return t;\n})();\n\nif (typeof module !== 'undefined') module.exports = toGeoJSON;\n"],"mappings":"AAAA,IAAIA,SAAS,GAAI,YAAW;EACxB,YAAY;;EAEZ,IAAIC,WAAW,GAAI,MAAO;IACtBC,SAAS,GAAI,YAAa;IAC1BC,UAAU,GAAI,KAAM;EACxB;EACA,SAASC,MAAMA,CAACC,CAAC,EAAE;IACf,IAAI,CAACA,CAAC,IAAI,CAACA,CAAC,CAACC,MAAM,EAAE,OAAO,CAAC;IAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGF,CAAC,CAACC,MAAM,EAAEC,CAAC,EAAE,EAAE;MACtCC,CAAC,GAAI,CAACA,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAIH,CAAC,CAACI,UAAU,CAACF,CAAC,CAAC,GAAG,CAAC;IAC5C;IAAE,OAAOC,CAAC;EACd;EACA;EACA,SAASE,GAAGA,CAACL,CAAC,EAAEM,CAAC,EAAE;IAAE,OAAON,CAAC,CAACO,oBAAoB,CAACD,CAAC,CAAC;EAAE;EACvD,SAASE,IAAIA,CAACR,CAAC,EAAEM,CAAC,EAAE;IAAE,OAAON,CAAC,CAACS,YAAY,CAACH,CAAC,CAAC;EAAE;EAChD,SAASI,KAAKA,CAACV,CAAC,EAAEM,CAAC,EAAE;IAAE,OAAOK,UAAU,CAACH,IAAI,CAACR,CAAC,EAAEM,CAAC,CAAC,CAAC;EAAE;EACtD;EACA,SAASM,IAAIA,CAACZ,CAAC,EAAEM,CAAC,EAAE;IAAE,IAAIO,CAAC,GAAGR,GAAG,CAACL,CAAC,EAAEM,CAAC,CAAC;IAAE,OAAOO,CAAC,CAACZ,MAAM,GAAGY,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;EAAE;EACxE;EACA,SAASC,IAAIA,CAACC,EAAE,EAAE;IAAE,IAAIA,EAAE,CAACC,SAAS,EAAE;MAAED,EAAE,CAACC,SAAS,CAAC,CAAC;IAAE;IAAE,OAAOD,EAAE;EAAE;EACrE;EACA,SAASE,QAAQA,CAACjB,CAAC,EAAE;IACjB,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,EAAE,EAAED,CAAC,GAAGlB,CAAC,CAACC,MAAM,EAAEiB,CAAC,EAAE,EAAE;MAAEC,CAAC,CAACD,CAAC,CAAC,GAAGP,UAAU,CAACX,CAAC,CAACkB,CAAC,CAAC,CAAC;IAAE;IACtE,OAAOC,CAAC;EACZ;EACA,SAASC,KAAKA,CAACpB,CAAC,EAAE;IACd,IAAImB,CAAC,GAAG,CAAC,CAAC;IACV,KAAK,IAAIjB,CAAC,IAAIF,CAAC,EAAE;MAAE,IAAIA,CAAC,CAACE,CAAC,CAAC,EAAE;QAAEiB,CAAC,CAACjB,CAAC,CAAC,GAAGF,CAAC,CAACE,CAAC,CAAC;MAAE;IAAE;IAC9C,OAAOiB,CAAC;EACZ;EACA;EACA,SAASE,OAAOA,CAACrB,CAAC,EAAE;IAChB,IAAIA,CAAC,EAAE;MAAEc,IAAI,CAACd,CAAC,CAAC;IAAE;IAClB,OAAQA,CAAC,IAAIA,CAAC,CAACsB,WAAW,IAAK,EAAE;EACrC;EACA;EACA,SAASC,MAAMA,CAACC,CAAC,EAAE;IAAE,OAAOP,QAAQ,CAACO,CAAC,CAACC,OAAO,CAAC7B,WAAW,EAAE,EAAE,CAAC,CAAC8B,KAAK,CAAC,GAAG,CAAC,CAAC;EAAE;EAC7E;EACA,SAASC,KAAKA,CAACH,CAAC,EAAE;IACd,IAAII,MAAM,GAAGJ,CAAC,CAACC,OAAO,CAAC5B,SAAS,EAAE,EAAE,CAAC,CAAC6B,KAAK,CAAC5B,UAAU,CAAC;MACnDqB,CAAC,GAAG,EAAE;IACV,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,MAAM,CAAC3B,MAAM,EAAEC,CAAC,EAAE,EAAE;MACpCiB,CAAC,CAACU,IAAI,CAACN,MAAM,CAACK,MAAM,CAAC1B,CAAC,CAAC,CAAC,CAAC;IAC7B;IACA,OAAOiB,CAAC;EACZ;EACA,SAASW,SAASA,CAAC9B,CAAC,EAAE;IAClB,IAAI+B,EAAE,GAAG,CAACrB,KAAK,CAACV,CAAC,EAAE,KAAK,CAAC,EAAEU,KAAK,CAACV,CAAC,EAAE,KAAK,CAAC,CAAC;MACvCgC,GAAG,GAAGpB,IAAI,CAACZ,CAAC,EAAE,KAAK,CAAC;MACpB;MACAiC,SAAS,GAAGrB,IAAI,CAACZ,CAAC,EAAE,WAAW,CAAC,IAAIY,IAAI,CAACZ,CAAC,EAAE,IAAI,CAAC;MACjDkC,IAAI,GAAGtB,IAAI,CAACZ,CAAC,EAAE,MAAM,CAAC;MACtBmC,CAAC;IACL,IAAIH,GAAG,EAAE;MACLG,CAAC,GAAGxB,UAAU,CAACU,OAAO,CAACW,GAAG,CAAC,CAAC;MAC5B,IAAI,CAACI,KAAK,CAACD,CAAC,CAAC,EAAE;QACXJ,EAAE,CAACF,IAAI,CAACM,CAAC,CAAC;MACd;IACJ;IACA,OAAO;MACHE,WAAW,EAAEN,EAAE;MACfG,IAAI,EAAEA,IAAI,GAAGb,OAAO,CAACa,IAAI,CAAC,GAAG,IAAI;MACjCD,SAAS,EAAEA,SAAS,GAAGtB,UAAU,CAACU,OAAO,CAACY,SAAS,CAAC,CAAC,GAAG;IAC5D,CAAC;EACL;;EAEA;EACA,SAASK,EAAEA,CAAA,EAAG;IACV,OAAO;MACHC,IAAI,EAAE,mBAAmB;MACzBC,QAAQ,EAAE;IACd,CAAC;EACL;EAEA,IAAIC,UAAU;EACd,IAAI,OAAOC,aAAa,KAAK,WAAW,EAAE;IACtC;IACAD,UAAU,GAAG,IAAIC,aAAa,CAAC,CAAC;IACpC;EACA,CAAC,MAAM,IAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,CAACA,OAAO,CAACC,OAAO,EAAE;IACvFJ,UAAU,GAAG,KAAKK,OAAO,CAAC,QAAQ,CAAC,CAACJ,aAAa,EAAE,CAAC;EACxD;EACA,SAASK,OAAOA,CAACC,GAAG,EAAE;IAClB;IACA;IACA;IACA,IAAIA,GAAG,CAACC,GAAG,KAAKC,SAAS,EAAE,OAAOF,GAAG,CAACC,GAAG;IACzC,OAAOR,UAAU,CAACU,iBAAiB,CAACH,GAAG,CAAC;EAC5C;EAEA,IAAII,CAAC,GAAG;IACJC,GAAG,EAAE,SAAAA,CAASC,GAAG,EAAE;MAEf,IAAIC,EAAE,GAAGjB,EAAE,CAAC,CAAC;QACT;QACAkB,UAAU,GAAG,CAAC,CAAC;QACf;QACA;QACAC,QAAQ,GAAG,CAAC,SAAS,EAAE,YAAY,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,CAAC;QAClE;QACAC,UAAU,GAAGrD,GAAG,CAACiD,GAAG,EAAE,WAAW,CAAC;QAClCK,MAAM,GAAGtD,GAAG,CAACiD,GAAG,EAAE,OAAO,CAAC;QAC1BM,SAAS,GAAGvD,GAAG,CAACiD,GAAG,EAAE,UAAU,CAAC;MAEpC,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAAC1D,MAAM,EAAE4D,CAAC,EAAE,EAAE;QACpCL,UAAU,CAAC,GAAG,GAAGhD,IAAI,CAACmD,MAAM,CAACE,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG9D,MAAM,CAACgD,OAAO,CAACY,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC;MACrF;MACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAAC3D,MAAM,EAAE8D,CAAC,EAAE,EAAE;QACvCP,UAAU,CAAC,GAAG,GAAGhD,IAAI,CAACoD,SAAS,CAACG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAGhE,MAAM,CAACgD,OAAO,CAACa,SAAS,CAACG,CAAC,CAAC,CAAC,CAAC,CAACD,QAAQ,CAAC,EAAE,CAAC;MAC3F;MACA,KAAK,IAAI5C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwC,UAAU,CAACzD,MAAM,EAAEiB,CAAC,EAAE,EAAE;QACxCqC,EAAE,CAACf,QAAQ,GAAGe,EAAE,CAACf,QAAQ,CAACwB,MAAM,CAACC,YAAY,CAACP,UAAU,CAACxC,CAAC,CAAC,CAAC,CAAC;MACjE;MACA,SAASgD,QAAQA,CAAC1C,CAAC,EAAE;QACjB,IAAI2C,KAAK,EAAEC,OAAO;QAClB5C,CAAC,GAAGA,CAAC,IAAI,EAAE;QACX,IAAIA,CAAC,CAAC6C,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;UAAE7C,CAAC,GAAGA,CAAC,CAAC6C,MAAM,CAAC,CAAC,CAAC;QAAE;QAC/C,IAAI7C,CAAC,CAACvB,MAAM,KAAK,CAAC,IAAIuB,CAAC,CAACvB,MAAM,KAAK,CAAC,EAAE;UAAEkE,KAAK,GAAG3C,CAAC;QAAE;QACnD,IAAIA,CAAC,CAACvB,MAAM,KAAK,CAAC,EAAE;UAChBmE,OAAO,GAAGE,QAAQ,CAAC9C,CAAC,CAAC6C,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG;UAC5CF,KAAK,GAAG,GAAG,GAAC3C,CAAC,CAAC6C,MAAM,CAAC,CAAC,CAAC;QAC3B;QACA,OAAO,CAACF,KAAK,EAAE/B,KAAK,CAACgC,OAAO,CAAC,GAAGlB,SAAS,GAAGkB,OAAO,CAAC;MACxD;MACA,SAASG,OAAOA,CAAC/C,CAAC,EAAE;QAAE,OAAOP,QAAQ,CAACO,CAAC,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC;MAAE;MACrD,SAAS8C,QAAQA,CAACC,IAAI,EAAE;QACpB,IAAIC,KAAK,GAAGrE,GAAG,CAACoE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC;UAAE7C,MAAM,GAAG,EAAE;UAAE+C,KAAK,GAAG,EAAE;QAC7D,IAAID,KAAK,CAACzE,MAAM,KAAK,CAAC,EAAEyE,KAAK,GAAGrE,GAAG,CAACoE,IAAI,EAAE,UAAU,CAAC;QACrD,KAAK,IAAIvE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwE,KAAK,CAACzE,MAAM,EAAEC,CAAC,EAAE,EAAE0B,MAAM,CAACC,IAAI,CAAC0C,OAAO,CAAClD,OAAO,CAACqD,KAAK,CAACxE,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9E,IAAI0E,SAAS,GAAGvE,GAAG,CAACoE,IAAI,EAAE,MAAM,CAAC;QACjC,KAAK,IAAIvD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0D,SAAS,CAAC3E,MAAM,EAAEiB,CAAC,EAAE,EAAEyD,KAAK,CAAC9C,IAAI,CAACR,OAAO,CAACuD,SAAS,CAAC1D,CAAC,CAAC,CAAC,CAAC;QAC5E,OAAO;UACHU,MAAM,EAAEA,MAAM;UACd+C,KAAK,EAAEA;QACX,CAAC;MACL;MACA,SAASE,WAAWA,CAACJ,IAAI,EAAE;QACvB,IAAIK,QAAQ;UAAEC,SAAS;UAAE7E,CAAC;UAAEgB,CAAC;UAAE2C,CAAC;UAAEmB,KAAK,GAAG,EAAE;UAAEC,UAAU,GAAG,EAAE;QAC7D,IAAIrE,IAAI,CAAC6D,IAAI,EAAE,eAAe,CAAC,EAAE;UAAE,OAAOI,WAAW,CAACjE,IAAI,CAAC6D,IAAI,EAAE,eAAe,CAAC,CAAC;QAAE;QACpF,IAAI7D,IAAI,CAAC6D,IAAI,EAAE,YAAY,CAAC,EAAE;UAAE,OAAOI,WAAW,CAACjE,IAAI,CAAC6D,IAAI,EAAE,YAAY,CAAC,CAAC;QAAE;QAC9E,IAAI7D,IAAI,CAAC6D,IAAI,EAAE,eAAe,CAAC,EAAE;UAAE,OAAOI,WAAW,CAACjE,IAAI,CAAC6D,IAAI,EAAE,eAAe,CAAC,CAAC;QAAE;QACpF,KAAKvE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuD,QAAQ,CAACxD,MAAM,EAAEC,CAAC,EAAE,EAAE;UAClC6E,SAAS,GAAG1E,GAAG,CAACoE,IAAI,EAAEhB,QAAQ,CAACvD,CAAC,CAAC,CAAC;UAClC,IAAI6E,SAAS,EAAE;YACX,KAAK7D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6D,SAAS,CAAC9E,MAAM,EAAEiB,CAAC,EAAE,EAAE;cACnC4D,QAAQ,GAAGC,SAAS,CAAC7D,CAAC,CAAC;cACvB,IAAIuC,QAAQ,CAACvD,CAAC,CAAC,KAAK,OAAO,EAAE;gBACzB8E,KAAK,CAACnD,IAAI,CAAC;kBACPU,IAAI,EAAE,OAAO;kBACbF,WAAW,EAAEd,MAAM,CAACF,OAAO,CAACT,IAAI,CAACkE,QAAQ,EAAE,aAAa,CAAC,CAAC;gBAC9D,CAAC,CAAC;cACN,CAAC,MAAM,IAAIrB,QAAQ,CAACvD,CAAC,CAAC,KAAK,YAAY,EAAE;gBACrC8E,KAAK,CAACnD,IAAI,CAAC;kBACPU,IAAI,EAAE,YAAY;kBAClBF,WAAW,EAAEV,KAAK,CAACN,OAAO,CAACT,IAAI,CAACkE,QAAQ,EAAE,aAAa,CAAC,CAAC;gBAC7D,CAAC,CAAC;cACN,CAAC,MAAM,IAAIrB,QAAQ,CAACvD,CAAC,CAAC,KAAK,SAAS,EAAE;gBAClC,IAAIgF,KAAK,GAAG7E,GAAG,CAACyE,QAAQ,EAAE,YAAY,CAAC;kBACnClD,MAAM,GAAG,EAAE;gBACf,KAAKiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,KAAK,CAACjF,MAAM,EAAE4D,CAAC,EAAE,EAAE;kBAC/BjC,MAAM,CAACC,IAAI,CAACF,KAAK,CAACN,OAAO,CAACT,IAAI,CAACsE,KAAK,CAACrB,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC;gBAC9D;gBACAmB,KAAK,CAACnD,IAAI,CAAC;kBACPU,IAAI,EAAE,SAAS;kBACfF,WAAW,EAAET;gBACjB,CAAC,CAAC;cACN,CAAC,MAAM,IAAI6B,QAAQ,CAACvD,CAAC,CAAC,KAAK,OAAO,IAC9BuD,QAAQ,CAACvD,CAAC,CAAC,KAAK,UAAU,EAAE;gBAC5B,IAAIiF,KAAK,GAAGX,QAAQ,CAACM,QAAQ,CAAC;gBAC9BE,KAAK,CAACnD,IAAI,CAAC;kBACPU,IAAI,EAAE,YAAY;kBAClBF,WAAW,EAAE8C,KAAK,CAACvD;gBACvB,CAAC,CAAC;gBACF,IAAIuD,KAAK,CAACR,KAAK,CAAC1E,MAAM,EAAEgF,UAAU,CAACpD,IAAI,CAACsD,KAAK,CAACR,KAAK,CAAC;cACxD;YACJ;UACJ;QACJ;QACA,OAAO;UACHK,KAAK,EAAEA,KAAK;UACZC,UAAU,EAAEA;QAChB,CAAC;MACL;MACA,SAAShB,YAAYA,CAACQ,IAAI,EAAE;QACxB,IAAIW,aAAa,GAAGP,WAAW,CAACJ,IAAI,CAAC;UAAEvE,CAAC;UAAEmF,UAAU,GAAG,CAAC,CAAC;UACrDC,IAAI,GAAGjE,OAAO,CAACT,IAAI,CAAC6D,IAAI,EAAE,MAAM,CAAC,CAAC;UAClCc,QAAQ,GAAGlE,OAAO,CAACT,IAAI,CAAC6D,IAAI,EAAE,UAAU,CAAC,CAAC;UAC1Ce,WAAW,GAAGnE,OAAO,CAACT,IAAI,CAAC6D,IAAI,EAAE,aAAa,CAAC,CAAC;UAChDgB,QAAQ,GAAG7E,IAAI,CAAC6D,IAAI,EAAE,UAAU,CAAC;UACjCiB,YAAY,GAAG9E,IAAI,CAAC6D,IAAI,EAAE,cAAc,CAAC;UACzCkB,SAAS,GAAG/E,IAAI,CAAC6D,IAAI,EAAE,WAAW,CAAC;UACnCmB,SAAS,GAAGhF,IAAI,CAAC6D,IAAI,EAAE,WAAW,CAAC;QAEvC,IAAI,CAACW,aAAa,CAACJ,KAAK,CAAC/E,MAAM,EAAE,OAAO,EAAE;QAC1C,IAAIqF,IAAI,EAAED,UAAU,CAACC,IAAI,GAAGA,IAAI;QAChC,IAAIC,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UACrBA,QAAQ,GAAG,GAAG,GAAGA,QAAQ;QAC7B;QACA,IAAIA,QAAQ,IAAI/B,UAAU,CAAC+B,QAAQ,CAAC,EAAE;UAClCF,UAAU,CAACE,QAAQ,GAAGA,QAAQ;UAC9BF,UAAU,CAACQ,SAAS,GAAGrC,UAAU,CAAC+B,QAAQ,CAAC;QAC/C;QACA,IAAIC,WAAW,EAAEH,UAAU,CAACG,WAAW,GAAGA,WAAW;QACrD,IAAIC,QAAQ,EAAE;UACV,IAAIK,KAAK,GAAGzE,OAAO,CAACT,IAAI,CAAC6E,QAAQ,EAAE,OAAO,CAAC,CAAC;UAC5C,IAAIM,GAAG,GAAG1E,OAAO,CAACT,IAAI,CAAC6E,QAAQ,EAAE,KAAK,CAAC,CAAC;UACxCJ,UAAU,CAACW,QAAQ,GAAG;YAAEF,KAAK,EAAEA,KAAK;YAAEC,GAAG,EAAEA;UAAI,CAAC;QACpD;QACA,IAAIJ,SAAS,EAAE;UACX,IAAIM,UAAU,GAAG/B,QAAQ,CAAC7C,OAAO,CAACT,IAAI,CAAC+E,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;YACxDxB,KAAK,GAAG8B,UAAU,CAAC,CAAC,CAAC;YACrB7B,OAAO,GAAG6B,UAAU,CAAC,CAAC,CAAC;YACvBC,KAAK,GAAGvF,UAAU,CAACU,OAAO,CAACT,IAAI,CAAC+E,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;UACzD,IAAIxB,KAAK,EAAEkB,UAAU,CAACc,MAAM,GAAGhC,KAAK;UACpC,IAAI,CAAC/B,KAAK,CAACgC,OAAO,CAAC,EAAEiB,UAAU,CAAC,gBAAgB,CAAC,GAAGjB,OAAO;UAC3D,IAAI,CAAChC,KAAK,CAAC8D,KAAK,CAAC,EAAEb,UAAU,CAAC,cAAc,CAAC,GAAGa,KAAK;QACzD;QACA,IAAIN,SAAS,EAAE;UACX,IAAIQ,UAAU,GAAGlC,QAAQ,CAAC7C,OAAO,CAACT,IAAI,CAACgF,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;YACxDS,MAAM,GAAGD,UAAU,CAAC,CAAC,CAAC;YACtBE,QAAQ,GAAGF,UAAU,CAAC,CAAC,CAAC;YACxBG,IAAI,GAAGlF,OAAO,CAACT,IAAI,CAACgF,SAAS,EAAE,MAAM,CAAC,CAAC;YACvCY,OAAO,GAAGnF,OAAO,CAACT,IAAI,CAACgF,SAAS,EAAE,SAAS,CAAC,CAAC;UACjD,IAAIS,MAAM,EAAEhB,UAAU,CAACkB,IAAI,GAAGF,MAAM;UACpC,IAAI,CAACjE,KAAK,CAACkE,QAAQ,CAAC,EAAEjB,UAAU,CAAC,cAAc,CAAC,GAAGiB,QAAQ;UAC3D,IAAIC,IAAI,EAAElB,UAAU,CAAC,cAAc,CAAC,GAAGkB,IAAI,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC;UAC3D,IAAIC,OAAO,EAAEnB,UAAU,CAAC,gBAAgB,CAAC,GAAGmB,OAAO,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC;QACvE;QACA,IAAId,YAAY,EAAE;UACd,IAAIe,KAAK,GAAGpG,GAAG,CAACqF,YAAY,EAAE,MAAM,CAAC;YACjCgB,WAAW,GAAGrG,GAAG,CAACqF,YAAY,EAAE,YAAY,CAAC;UAEjD,KAAKxF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuG,KAAK,CAACxG,MAAM,EAAEC,CAAC,EAAE,EAAE;YAC/BmF,UAAU,CAACoB,KAAK,CAACvG,CAAC,CAAC,CAACO,YAAY,CAAC,MAAM,CAAC,CAAC,GAAGY,OAAO,CAACT,IAAI,CAAC6F,KAAK,CAACvG,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;UAChF;UACA,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwG,WAAW,CAACzG,MAAM,EAAEC,CAAC,EAAE,EAAE;YACrCmF,UAAU,CAACqB,WAAW,CAACxG,CAAC,CAAC,CAACO,YAAY,CAAC,MAAM,CAAC,CAAC,GAAGY,OAAO,CAACqF,WAAW,CAACxG,CAAC,CAAC,CAAC;UAC7E;QACJ;QACA,IAAIkF,aAAa,CAACH,UAAU,CAAChF,MAAM,EAAE;UACjCoF,UAAU,CAACJ,UAAU,GAAIG,aAAa,CAACH,UAAU,CAAChF,MAAM,KAAK,CAAC,GAC1DmF,aAAa,CAACH,UAAU,CAAC,CAAC,CAAC,GAAGG,aAAa,CAACH,UAAU;QAC9D;QACA,IAAI0B,OAAO,GAAG;UACVpE,IAAI,EAAE,SAAS;UACfqE,QAAQ,EAAGxB,aAAa,CAACJ,KAAK,CAAC/E,MAAM,KAAK,CAAC,GAAImF,aAAa,CAACJ,KAAK,CAAC,CAAC,CAAC,GAAG;YACpEzC,IAAI,EAAE,oBAAoB;YAC1BsE,UAAU,EAAEzB,aAAa,CAACJ;UAC9B,CAAC;UACDK,UAAU,EAAEA;QAChB,CAAC;QACD,IAAI7E,IAAI,CAACiE,IAAI,EAAE,IAAI,CAAC,EAAEkC,OAAO,CAACG,EAAE,GAAGtG,IAAI,CAACiE,IAAI,EAAE,IAAI,CAAC;QACnD,OAAO,CAACkC,OAAO,CAAC;MACpB;MACA,OAAOpD,EAAE;IACb,CAAC;IACDwD,GAAG,EAAE,SAAAA,CAASzD,GAAG,EAAE;MACf,IAAIpD,CAAC;QACD8G,MAAM,GAAG3G,GAAG,CAACiD,GAAG,EAAE,KAAK,CAAC;QACxB2D,MAAM,GAAG5G,GAAG,CAACiD,GAAG,EAAE,KAAK,CAAC;QACxB4D,SAAS,GAAG7G,GAAG,CAACiD,GAAG,EAAE,KAAK,CAAC;QAC3B;QACAC,EAAE,GAAGjB,EAAE,CAAC,CAAC;QACTqE,OAAO;MACX,KAAKzG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8G,MAAM,CAAC/G,MAAM,EAAEC,CAAC,EAAE,EAAE;QAChCyG,OAAO,GAAGQ,QAAQ,CAACH,MAAM,CAAC9G,CAAC,CAAC,CAAC;QAC7B,IAAIyG,OAAO,EAAEpD,EAAE,CAACf,QAAQ,CAACX,IAAI,CAAC8E,OAAO,CAAC;MAC1C;MACA,KAAKzG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+G,MAAM,CAAChH,MAAM,EAAEC,CAAC,EAAE,EAAE;QAChCyG,OAAO,GAAGS,QAAQ,CAACH,MAAM,CAAC/G,CAAC,CAAC,CAAC;QAC7B,IAAIyG,OAAO,EAAEpD,EAAE,CAACf,QAAQ,CAACX,IAAI,CAAC8E,OAAO,CAAC;MAC1C;MACA,KAAKzG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgH,SAAS,CAACjH,MAAM,EAAEC,CAAC,EAAE,EAAE;QACnCqD,EAAE,CAACf,QAAQ,CAACX,IAAI,CAACwF,QAAQ,CAACH,SAAS,CAAChH,CAAC,CAAC,CAAC,CAAC;MAC5C;MACA,SAASoH,SAASA,CAACC,IAAI,EAAEC,SAAS,EAAE;QAChC,IAAIC,GAAG,GAAGpH,GAAG,CAACkH,IAAI,EAAEC,SAAS,CAAC;UAC1BE,IAAI,GAAG,EAAE;UACT/C,KAAK,GAAG,EAAE;UACVgD,UAAU,GAAG,EAAE;UACf5D,CAAC,GAAG0D,GAAG,CAACxH,MAAM;QAClB,IAAI8D,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAE;QACvB,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6D,CAAC,EAAE7D,CAAC,EAAE,EAAE;UACxB,IAAI0H,CAAC,GAAG9F,SAAS,CAAC2F,GAAG,CAACvH,CAAC,CAAC,CAAC;UACzBwH,IAAI,CAAC7F,IAAI,CAAC+F,CAAC,CAACvF,WAAW,CAAC;UACxB,IAAIuF,CAAC,CAAC1F,IAAI,EAAEyC,KAAK,CAAC9C,IAAI,CAAC+F,CAAC,CAAC1F,IAAI,CAAC;UAC9B,IAAI0F,CAAC,CAAC3F,SAAS,EAAE0F,UAAU,CAAC9F,IAAI,CAAC+F,CAAC,CAAC3F,SAAS,CAAC;QACjD;QACA,OAAO;UACHyF,IAAI,EAAEA,IAAI;UACV/C,KAAK,EAAEA,KAAK;UACZgD,UAAU,EAAEA;QAChB,CAAC;MACL;MACA,SAASR,QAAQA,CAACI,IAAI,EAAE;QACpB,IAAIM,QAAQ,GAAGxH,GAAG,CAACkH,IAAI,EAAE,QAAQ,CAAC;UAC9BpC,KAAK,GAAG,EAAE;UACVR,KAAK,GAAG,EAAE;UACVgD,UAAU,GAAG,EAAE;UACfD,IAAI;QACR,KAAK,IAAIxH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2H,QAAQ,CAAC5H,MAAM,EAAEC,CAAC,EAAE,EAAE;UACtCwH,IAAI,GAAGJ,SAAS,CAACO,QAAQ,CAAC3H,CAAC,CAAC,EAAE,OAAO,CAAC;UACtC,IAAIwH,IAAI,CAACA,IAAI,EAAEvC,KAAK,CAACtD,IAAI,CAAC6F,IAAI,CAACA,IAAI,CAAC;UACpC,IAAIA,IAAI,CAAC/C,KAAK,IAAI+C,IAAI,CAAC/C,KAAK,CAAC1E,MAAM,EAAE0E,KAAK,CAAC9C,IAAI,CAAC6F,IAAI,CAAC/C,KAAK,CAAC;UAC3D,IAAI+C,IAAI,CAACC,UAAU,IAAID,IAAI,CAACC,UAAU,CAAC1H,MAAM,EAAE0H,UAAU,CAAC9F,IAAI,CAAC6F,IAAI,CAACC,UAAU,CAAC;QACnF;QACA,IAAIxC,KAAK,CAAClF,MAAM,KAAK,CAAC,EAAE;QACxB,IAAIoF,UAAU,GAAGyC,aAAa,CAACP,IAAI,CAAC;QACpC,IAAI5C,KAAK,CAAC1E,MAAM,EAAEoF,UAAU,CAACJ,UAAU,GAAGE,KAAK,CAAClF,MAAM,KAAK,CAAC,GAAG0E,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK;QAC/E,IAAIgD,UAAU,CAAC1H,MAAM,EAAEoF,UAAU,CAACsC,UAAU,GAAGxC,KAAK,CAAClF,MAAM,KAAK,CAAC,GAAG0H,UAAU,CAAC,CAAC,CAAC,GAAGA,UAAU;QAC9F,OAAO;UACHpF,IAAI,EAAE,SAAS;UACf8C,UAAU,EAAEA,UAAU;UACtBuB,QAAQ,EAAE;YACNrE,IAAI,EAAE4C,KAAK,CAAClF,MAAM,KAAK,CAAC,GAAG,YAAY,GAAG,iBAAiB;YAC3DoC,WAAW,EAAE8C,KAAK,CAAClF,MAAM,KAAK,CAAC,GAAGkF,KAAK,CAAC,CAAC,CAAC,GAAGA;UACjD;QACJ,CAAC;MACL;MACA,SAASiC,QAAQA,CAACG,IAAI,EAAE;QACpB,IAAIG,IAAI,GAAGJ,SAAS,CAACC,IAAI,EAAE,OAAO,CAAC;QACnC,IAAI,CAACG,IAAI,CAACA,IAAI,EAAE;QAChB,IAAIK,QAAQ,GAAG;UACXxF,IAAI,EAAE,SAAS;UACf8C,UAAU,EAAEyC,aAAa,CAACP,IAAI,CAAC;UAC/BX,QAAQ,EAAE;YACNrE,IAAI,EAAE,YAAY;YAClBF,WAAW,EAAEqF,IAAI,CAACA;UACtB;QACJ,CAAC;QACD,OAAOK,QAAQ;MACnB;MACA,SAASV,QAAQA,CAACE,IAAI,EAAE;QACpB,IAAIS,IAAI,GAAGF,aAAa,CAACP,IAAI,CAAC;QAC9BS,IAAI,CAACC,GAAG,GAAG5G,OAAO,CAACT,IAAI,CAAC2G,IAAI,EAAE,KAAK,CAAC,CAAC;QACrC,OAAO;UACHhF,IAAI,EAAE,SAAS;UACf8C,UAAU,EAAE2C,IAAI;UAChBpB,QAAQ,EAAE;YACNrE,IAAI,EAAE,OAAO;YACbF,WAAW,EAAEP,SAAS,CAACyF,IAAI,CAAC,CAAClF;UACjC;QACJ,CAAC;MACL;MACA,SAASyF,aAAaA,CAACP,IAAI,EAAE;QACzB,IAAIW,IAAI,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,MAAM,EAC7C,MAAM,EAAE,UAAU,CAAC;UAC3BF,IAAI,GAAG,CAAC,CAAC;UACTnE,CAAC;QACL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqE,IAAI,CAACjI,MAAM,EAAE4D,CAAC,EAAE,EAAE;UAC9BmE,IAAI,CAACE,IAAI,CAACrE,CAAC,CAAC,CAAC,GAAGxC,OAAO,CAACT,IAAI,CAAC2G,IAAI,EAAEW,IAAI,CAACrE,CAAC,CAAC,CAAC,CAAC;QAChD;QACA,OAAOzC,KAAK,CAAC4G,IAAI,CAAC;MACtB;MACA,OAAOzE,EAAE;IACb;EACJ,CAAC;EACD,OAAOH,CAAC;AACZ,CAAC,CAAE,CAAC;AAEJ,IAAI,OAAO+E,MAAM,KAAK,WAAW,EAAEA,MAAM,CAACxF,OAAO,GAAGhD,SAAS"},"metadata":{},"sourceType":"script"}