{"ast":null,"code":"var createDecoder = require('./decoder');\nfunction dbfHeader(data) {\n  var out = {};\n  out.lastUpdated = new Date(data.readUInt8(1) + 1900, data.readUInt8(2), data.readUInt8(3));\n  out.records = data.readUInt32LE(4);\n  out.headerLen = data.readUInt16LE(8);\n  out.recLen = data.readUInt16LE(10);\n  return out;\n}\nfunction dbfRowHeader(data, headerLen, decoder) {\n  var out = [];\n  var offset = 32;\n  while (offset < headerLen) {\n    out.push({\n      name: decoder(data.slice(offset, offset + 11)),\n      dataType: String.fromCharCode(data.readUInt8(offset + 11)),\n      len: data.readUInt8(offset + 16),\n      decimal: data.readUInt8(offset + 17)\n    });\n    if (data.readUInt8(offset + 32) === 13) {\n      break;\n    } else {\n      offset += 32;\n    }\n  }\n  return out;\n}\nfunction rowFuncs(buffer, offset, len, type, decoder) {\n  var data = buffer.slice(offset, offset + len);\n  var textData = decoder(data);\n  switch (type) {\n    case 'N':\n    case 'F':\n    case 'O':\n      return parseFloat(textData, 10);\n    case 'D':\n      return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));\n    case 'L':\n      return textData.toLowerCase() === 'y' || textData.toLowerCase() === 't';\n    default:\n      return textData;\n  }\n}\nfunction parseRow(buffer, offset, rowHeaders, decoder) {\n  var out = {};\n  var i = 0;\n  var len = rowHeaders.length;\n  var field;\n  var header;\n  while (i < len) {\n    header = rowHeaders[i];\n    field = rowFuncs(buffer, offset, header.len, header.dataType, decoder);\n    offset += header.len;\n    if (typeof field !== 'undefined') {\n      out[header.name] = field;\n    }\n    i++;\n  }\n  return out;\n}\nmodule.exports = function (buffer, encoding) {\n  var decoder = createDecoder(encoding);\n  var header = dbfHeader(buffer);\n  var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1, decoder);\n  var offset = (rowHeaders.length + 1 << 5) + 2;\n  var recLen = header.recLen;\n  var records = header.records;\n  var out = [];\n  while (records) {\n    out.push(parseRow(buffer, offset, rowHeaders, decoder));\n    offset += recLen;\n    records--;\n  }\n  return out;\n};","map":{"version":3,"names":["createDecoder","require","dbfHeader","data","out","lastUpdated","Date","readUInt8","records","readUInt32LE","headerLen","readUInt16LE","recLen","dbfRowHeader","decoder","offset","push","name","slice","dataType","String","fromCharCode","len","decimal","rowFuncs","buffer","type","textData","parseFloat","parseInt","toLowerCase","parseRow","rowHeaders","i","length","field","header","module","exports","encoding"],"sources":["C:/Users/haosh/desktop/CSE416 projec/MapGroupProject/node_modules/parsedbf/index.js"],"sourcesContent":["var createDecoder = require('./decoder');\nfunction dbfHeader(data) {\n  var out = {};\n  out.lastUpdated = new Date(data.readUInt8(1) + 1900, data.readUInt8(2), data.readUInt8(3));\n  out.records = data.readUInt32LE(4);\n  out.headerLen = data.readUInt16LE(8);\n  out.recLen = data.readUInt16LE(10);\n  return out;\n}\n\nfunction dbfRowHeader(data, headerLen, decoder) {\n  var out = [];\n  var offset = 32;\n  while (offset < headerLen) {\n    out.push({\n      name: decoder(data.slice(offset, offset + 11)),\n      dataType: String.fromCharCode(data.readUInt8(offset + 11)),\n      len: data.readUInt8(offset + 16),\n      decimal: data.readUInt8(offset + 17)\n    });\n    if (data.readUInt8(offset + 32) === 13) {\n      break;\n    } else {\n      offset += 32;\n    }\n  }\n  return out;\n}\n\nfunction rowFuncs(buffer, offset, len, type, decoder) {\n  var data = buffer.slice(offset, offset + len);\n  var textData = decoder(data);\n  switch (type) {\n    case 'N':\n    case 'F':\n    case 'O':\n      return parseFloat(textData, 10);\n    case 'D':\n      return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));\n    case 'L':\n      return textData.toLowerCase() === 'y' || textData.toLowerCase() === 't';\n    default:\n      return textData;\n  }\n}\n\nfunction parseRow(buffer, offset, rowHeaders, decoder) {\n  var out = {};\n  var i = 0;\n  var len = rowHeaders.length;\n  var field;\n  var header;\n  while (i < len) {\n    header = rowHeaders[i];\n    field = rowFuncs(buffer, offset, header.len, header.dataType, decoder);\n    offset += header.len;\n    if (typeof field !== 'undefined') {\n      out[header.name] = field;\n    }\n    i++;\n  }\n  return out;\n}\n\nmodule.exports = function(buffer, encoding) {\n  var decoder = createDecoder(encoding);\n  var header = dbfHeader(buffer);\n  var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1, decoder);\n\n  var offset = ((rowHeaders.length + 1) << 5) + 2;\n  var recLen = header.recLen;\n  var records = header.records;\n  var out = [];\n  while (records) {\n    out.push(parseRow(buffer, offset, rowHeaders, decoder));\n    offset += recLen;\n    records--;\n  }\n  return out;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}