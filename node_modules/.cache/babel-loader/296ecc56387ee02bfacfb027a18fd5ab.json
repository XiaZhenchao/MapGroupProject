{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).toGeoJSON = {});\n}(this, function (t) {\n  \"use strict\";\n\n  function e(t, e) {\n    return Array.from(t.getElementsByTagName(e));\n  }\n  function n(t) {\n    return \"#\" === t[0] ? t : `#${t}`;\n  }\n  function o(t) {\n    return t?.normalize(), t && t.textContent || \"\";\n  }\n  function r(t, e, n) {\n    const o = t.getElementsByTagName(e),\n      r = o.length ? o[0] : null;\n    return r && n && n(r), r;\n  }\n  function i(t, e, n) {\n    const o = {};\n    if (!t) return o;\n    const r = t.getElementsByTagName(e),\n      i = r.length ? r[0] : null;\n    return i && n ? n(i, o) : o;\n  }\n  function s(t, e, n) {\n    const i = o(r(t, e));\n    return i && n && n(i) || {};\n  }\n  function c(t, e, n) {\n    const i = parseFloat(o(r(t, e)));\n    if (!isNaN(i)) return i && n && n(i) || {};\n  }\n  function a(t, e, n) {\n    const i = parseFloat(o(r(t, e)));\n    if (!isNaN(i)) return n && n(i), i;\n  }\n  function l(t, e) {\n    const n = {};\n    for (const o of e) s(t, o, t => {\n      n[o] = t;\n    });\n    return n;\n  }\n  function u(t) {\n    return 1 === t?.nodeType;\n  }\n  function f(t) {\n    return i(t, \"line\", t => Object.assign({}, s(t, \"color\", t => ({\n      stroke: `#${t}`\n    })), c(t, \"opacity\", t => ({\n      \"stroke-opacity\": t\n    })), c(t, \"width\", t => ({\n      \"stroke-width\": 96 * t / 25.4\n    }))));\n  }\n  function p(t) {\n    let e = [];\n    if (null === t) return e;\n    for (const n of Array.from(t.childNodes)) {\n      if (!u(n)) continue;\n      const t = g(n.nodeName);\n      if (\"gpxtpx:TrackPointExtension\" === t) e = e.concat(p(n));else {\n        const r = o(n);\n        e.push([t, d(r)]);\n      }\n    }\n    return e;\n  }\n  function g(t) {\n    return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(t) ? \"heart\" : t;\n  }\n  function d(t) {\n    const e = parseFloat(t);\n    return isNaN(e) ? t : e;\n  }\n  function m(t) {\n    const e = [parseFloat(t.getAttribute(\"lon\") || \"\"), parseFloat(t.getAttribute(\"lat\") || \"\")];\n    if (isNaN(e[0]) || isNaN(e[1])) return null;\n    a(t, \"ele\", t => {\n      e.push(t);\n    });\n    const n = r(t, \"time\");\n    return {\n      coordinates: e,\n      time: n ? o(n) : null,\n      extendedValues: p(r(t, \"extensions\"))\n    };\n  }\n  function h(t) {\n    const n = l(t, [\"name\", \"cmt\", \"desc\", \"type\", \"time\", \"keywords\"]),\n      r = Array.from(t.getElementsByTagNameNS(\"http://www.garmin.com/xmlschemas/GpxExtensions/v3\", \"*\"));\n    for (const e of r) e.parentNode?.parentNode === t && (n[e.tagName.replace(\":\", \"_\")] = o(e));\n    const i = e(t, \"link\");\n    return i.length && (n.links = i.map(t => Object.assign({\n      href: t.getAttribute(\"href\")\n    }, l(t, [\"text\", \"type\"])))), n;\n  }\n  function y(t, n) {\n    const o = e(t, n),\n      r = [],\n      i = [],\n      s = {};\n    for (let t = 0; t < o.length; t++) {\n      const e = m(o[t]);\n      if (e) {\n        r.push(e.coordinates), e.time && i.push(e.time);\n        for (const [n, r] of e.extendedValues) {\n          const e = \"heart\" === n ? n : n.replace(\"gpxtpx:\", \"\") + \"s\";\n          s[e] || (s[e] = Array(o.length).fill(null)), s[e][t] = r;\n        }\n      }\n    }\n    if (!(r.length < 2)) return {\n      line: r,\n      times: i,\n      extendedValues: s\n    };\n  }\n  function b(t) {\n    const e = y(t, \"rtept\");\n    if (e) return {\n      type: \"Feature\",\n      properties: Object.assign({\n        _gpxType: \"rte\"\n      }, h(t), f(r(t, \"extensions\"))),\n      geometry: {\n        type: \"LineString\",\n        coordinates: e.line\n      }\n    };\n  }\n  function N(t) {\n    const n = e(t, \"trkseg\"),\n      o = [],\n      i = [],\n      s = [];\n    for (const t of n) {\n      const e = y(t, \"trkpt\");\n      e && (s.push(e), e.times && e.times.length && i.push(e.times));\n    }\n    if (0 === s.length) return null;\n    const c = s.length > 1,\n      a = Object.assign({\n        _gpxType: \"trk\"\n      }, h(t), f(r(t, \"extensions\")), i.length ? {\n        coordinateProperties: {\n          times: c ? i : i[0]\n        }\n      } : {});\n    for (const t of s) {\n      o.push(t.line), a.coordinateProperties || (a.coordinateProperties = {});\n      const e = a.coordinateProperties,\n        n = Object.entries(t.extendedValues);\n      for (let t = 0; t < n.length; t++) {\n        const [o, r] = n[t];\n        c ? (e[o] || (e[o] = s.map(t => new Array(t.line.length).fill(null))), e[o][t] = r) : e[o] = r;\n      }\n    }\n    return {\n      type: \"Feature\",\n      properties: a,\n      geometry: c ? {\n        type: \"MultiLineString\",\n        coordinates: o\n      } : {\n        type: \"LineString\",\n        coordinates: o[0]\n      }\n    };\n  }\n  function x(t) {\n    const e = Object.assign(h(t), l(t, [\"sym\"])),\n      n = m(t);\n    return n ? {\n      type: \"Feature\",\n      properties: e,\n      geometry: {\n        type: \"Point\",\n        coordinates: n.coordinates\n      }\n    } : null;\n  }\n  function* k(t) {\n    for (const n of e(t, \"trk\")) {\n      const t = N(n);\n      t && (yield t);\n    }\n    for (const n of e(t, \"rte\")) {\n      const t = b(n);\n      t && (yield t);\n    }\n    for (const n of e(t, \"wpt\")) {\n      const t = x(n);\n      t && (yield t);\n    }\n  }\n  const A = [[\"heartRate\", \"heartRates\"], [\"Cadence\", \"cadences\"], [\"Speed\", \"speeds\"], [\"Watts\", \"watts\"]],\n    S = [[\"TotalTimeSeconds\", \"totalTimeSeconds\"], [\"DistanceMeters\", \"distanceMeters\"], [\"MaximumSpeed\", \"maxSpeed\"], [\"AverageHeartRateBpm\", \"avgHeartRate\"], [\"MaximumHeartRateBpm\", \"maxHeartRate\"], [\"AvgSpeed\", \"avgSpeed\"], [\"AvgWatts\", \"avgWatts\"], [\"MaxWatts\", \"maxWatts\"]];\n  function v(t, e) {\n    const n = [];\n    for (const [i, s] of e) {\n      let e = r(t, i);\n      if (!e) {\n        const n = t.getElementsByTagNameNS(\"http://www.garmin.com/xmlschemas/ActivityExtension/v2\", i);\n        n.length && (e = n[0]);\n      }\n      const c = parseFloat(o(e));\n      isNaN(c) || n.push([s, c]);\n    }\n    return n;\n  }\n  function T(t) {\n    const e = [a(t, \"LongitudeDegrees\"), a(t, \"LatitudeDegrees\")];\n    if (void 0 === e[0] || isNaN(e[0]) || void 0 === e[1] || isNaN(e[1])) return null;\n    const n = r(t, \"HeartRateBpm\"),\n      i = o(r(t, \"Time\"));\n    return r(t, \"AltitudeMeters\", t => {\n      const n = parseFloat(o(t));\n      isNaN(n) || e.push(n);\n    }), {\n      coordinates: e,\n      time: i || null,\n      heartRate: n ? parseFloat(o(n)) : null,\n      extensions: v(t, A)\n    };\n  }\n  function F(t) {\n    const n = e(t, \"Trackpoint\"),\n      o = [],\n      r = [],\n      i = [];\n    if (n.length < 2) return null;\n    const s = {},\n      c = {\n        extendedProperties: s\n      };\n    for (let t = 0; t < n.length; t++) {\n      const e = T(n[t]);\n      if (null === e) continue;\n      o.push(e.coordinates);\n      const {\n        time: c,\n        heartRate: a,\n        extensions: l\n      } = e;\n      c && r.push(c), a && i.push(a);\n      for (const [e, o] of l) s[e] || (s[e] = Array(n.length).fill(null)), s[e][t] = o;\n    }\n    return o.length < 2 ? null : Object.assign(c, {\n      line: o,\n      times: r,\n      heartRates: i\n    });\n  }\n  function P(t) {\n    const n = e(t, \"Track\"),\n      r = [],\n      s = [],\n      c = [],\n      a = [];\n    let l;\n    const u = Object.assign(Object.fromEntries(v(t, S)), i(t, \"Name\", t => ({\n      name: o(t)\n    })));\n    for (const t of n) l = F(t), l && (r.push(l.line), l.times.length && s.push(l.times), l.heartRates.length && c.push(l.heartRates), a.push(l.extendedProperties));\n    for (let t = 0; t < a.length; t++) {\n      const e = a[t];\n      for (const o in e) 1 === n.length ? l && (u[o] = l.extendedProperties[o]) : (u[o] || (u[o] = r.map(t => Array(t.length).fill(null))), u[o][t] = e[o]);\n    }\n    return 0 === r.length ? null : ((s.length || c.length) && (u.coordinateProperties = Object.assign(s.length ? {\n      times: 1 === r.length ? s[0] : s\n    } : {}, c.length ? {\n      heart: 1 === r.length ? c[0] : c\n    } : {})), {\n      type: \"Feature\",\n      properties: u,\n      geometry: 1 === r.length ? {\n        type: \"LineString\",\n        coordinates: r[0]\n      } : {\n        type: \"MultiLineString\",\n        coordinates: r\n      }\n    });\n  }\n  function* O(t) {\n    for (const n of e(t, \"Lap\")) {\n      const t = P(n);\n      t && (yield t);\n    }\n    for (const n of e(t, \"Courses\")) {\n      const t = P(n);\n      t && (yield t);\n    }\n  }\n  function w(t, e) {\n    const n = {},\n      o = \"stroke\" == e || \"fill\" === e ? e : e + \"-color\";\n    return \"#\" === t[0] && (t = t.substring(1)), 6 === t.length || 3 === t.length ? n[o] = \"#\" + t : 8 === t.length && (n[e + \"-opacity\"] = parseInt(t.substring(0, 2), 16) / 255, n[o] = \"#\" + t.substring(6, 8) + t.substring(4, 6) + t.substring(2, 4)), n;\n  }\n  function M(t, e, n) {\n    const o = {};\n    return a(t, e, t => {\n      o[n] = t;\n    }), o;\n  }\n  function j(t, e) {\n    return i(t, \"color\", t => w(o(t), e));\n  }\n  function L(t) {\n    return i(t, \"Icon\", (t, e) => (s(t, \"href\", t => {\n      e.icon = t;\n    }), e));\n  }\n  function G(t) {\n    return Object.assign({}, function (t) {\n      return i(t, \"PolyStyle\", (t, e) => Object.assign(e, i(t, \"color\", t => w(o(t), \"fill\")), s(t, \"fill\", t => {\n        if (\"0\" === t) return {\n          \"fill-opacity\": 0\n        };\n      }), s(t, \"outline\", t => {\n        if (\"0\" === t) return {\n          \"stroke-opacity\": 0\n        };\n      })));\n    }(t), function (t) {\n      return i(t, \"LineStyle\", t => Object.assign(j(t, \"stroke\"), M(t, \"width\", \"stroke-width\")));\n    }(t), function (t) {\n      return i(t, \"LabelStyle\", t => Object.assign(j(t, \"label\"), M(t, \"scale\", \"label-scale\")));\n    }(t), function (t) {\n      return i(t, \"IconStyle\", t => Object.assign(j(t, \"icon\"), M(t, \"scale\", \"icon-scale\"), M(t, \"heading\", \"icon-heading\"), i(t, \"hotSpot\", t => {\n        const e = parseFloat(t.getAttribute(\"x\") || \"\"),\n          n = parseFloat(t.getAttribute(\"y\") || \"\"),\n          o = t.getAttribute(\"xunits\") || \"\",\n          r = t.getAttribute(\"yunits\") || \"\";\n        return isNaN(e) || isNaN(n) ? {} : {\n          \"icon-offset\": [e, n],\n          \"icon-offset-units\": [o, r]\n        };\n      }), L(t)));\n    }(t));\n  }\n  const R = t => Number(t),\n    B = {\n      string: t => t,\n      int: R,\n      uint: R,\n      short: R,\n      ushort: R,\n      float: R,\n      double: R,\n      bool: t => Boolean(t)\n    };\n  function E(t, n) {\n    return i(t, \"ExtendedData\", (t, i) => {\n      for (const n of e(t, \"Data\")) i[n.getAttribute(\"name\") || \"\"] = o(r(n, \"value\"));\n      for (const r of e(t, \"SimpleData\")) {\n        const t = r.getAttribute(\"name\") || \"\",\n          e = n[t] || B.string;\n        i[t] = e(o(r));\n      }\n      return i;\n    });\n  }\n  function C(t) {\n    const e = r(t, \"description\");\n    for (const t of Array.from(e?.childNodes || [])) if (4 === t.nodeType) return {\n      description: {\n        \"@type\": \"html\",\n        value: o(t)\n      }\n    };\n    return {};\n  }\n  function D(t) {\n    return i(t, \"TimeSpan\", t => ({\n      timespan: {\n        begin: o(r(t, \"begin\")),\n        end: o(r(t, \"end\"))\n      }\n    }));\n  }\n  function W(t) {\n    return i(t, \"TimeStamp\", t => ({\n      timestamp: o(r(t, \"when\"))\n    }));\n  }\n  function H(t, e) {\n    return s(t, \"styleUrl\", t => (t = n(t), e[t] ? Object.assign({\n      styleUrl: t\n    }, e[t]) : {\n      styleUrl: t\n    }));\n  }\n  const _ = /\\s*/g,\n    I = /^\\s*|\\s*$/g,\n    U = /\\s+/;\n  function V(t) {\n    return t.replace(_, \"\").split(\",\").map(parseFloat).filter(t => !isNaN(t)).slice(0, 3);\n  }\n  function $(t) {\n    return t.replace(I, \"\").split(U).map(V).filter(t => t.length >= 2);\n  }\n  function q(t) {\n    let n = e(t, \"coord\");\n    var r, i, s;\n    0 === n.length && (r = t, i = \"coord\", s = \"*\", n = Array.from(r.getElementsByTagNameNS(s, i)));\n    const c = n.map(t => o(t).split(\" \").map(parseFloat));\n    return 0 === c.length ? null : {\n      geometry: c.length > 2 ? {\n        type: \"LineString\",\n        coordinates: c\n      } : {\n        type: \"Point\",\n        coordinates: c[0]\n      },\n      times: e(t, \"when\").map(t => o(t))\n    };\n  }\n  function z(t) {\n    if (0 === t.length) return t;\n    const e = t[0],\n      n = t[t.length - 1];\n    let o = !0;\n    for (let t = 0; t < Math.max(e.length, n.length); t++) if (e[t] !== n[t]) {\n      o = !1;\n      break;\n    }\n    return o ? t : t.concat([t[0]]);\n  }\n  function J(t) {\n    return o(r(t, \"coordinates\"));\n  }\n  function Q(t) {\n    let n = [],\n      o = [];\n    for (let r = 0; r < t.childNodes.length; r++) {\n      const i = t.childNodes.item(r);\n      if (u(i)) switch (i.tagName) {\n        case \"MultiGeometry\":\n        case \"MultiTrack\":\n        case \"gx:MultiTrack\":\n          {\n            const t = Q(i);\n            n = n.concat(t.geometries), o = o.concat(t.coordTimes);\n            break;\n          }\n        case \"Point\":\n          {\n            const t = V(J(i));\n            t.length >= 2 && n.push({\n              type: \"Point\",\n              coordinates: t\n            });\n            break;\n          }\n        case \"LinearRing\":\n        case \"LineString\":\n          {\n            const t = $(J(i));\n            t.length >= 2 && n.push({\n              type: \"LineString\",\n              coordinates: t\n            });\n            break;\n          }\n        case \"Polygon\":\n          {\n            const t = [];\n            for (const n of e(i, \"LinearRing\")) {\n              const e = z($(J(n)));\n              e.length >= 4 && t.push(e);\n            }\n            t.length && n.push({\n              type: \"Polygon\",\n              coordinates: t\n            });\n            break;\n          }\n        case \"Track\":\n        case \"gx:Track\":\n          {\n            const t = q(i);\n            if (!t) break;\n            const {\n              times: e,\n              geometry: r\n            } = t;\n            n.push(r), e.length && o.push(e);\n            break;\n          }\n      }\n    }\n    return {\n      geometries: n,\n      coordTimes: o\n    };\n  }\n  function K(t, e, n, o) {\n    const {\n        coordTimes: r,\n        geometries: i\n      } = Q(t),\n      s = function (t) {\n        return 0 === t.length ? null : 1 === t.length ? t[0] : {\n          type: \"GeometryCollection\",\n          geometries: t\n        };\n      }(i);\n    if (!s && o.skipNullGeometry) return null;\n    const c = {\n      type: \"Feature\",\n      geometry: s,\n      properties: Object.assign(l(t, [\"name\", \"address\", \"visibility\", \"open\", \"phoneNumber\", \"description\"]), C(t), H(t, e), G(t), E(t, n), D(t), W(t), r.length ? {\n        coordinateProperties: {\n          times: 1 === r.length ? r[0] : r\n        }\n      } : {})\n    };\n    void 0 !== c.properties?.visibility && (c.properties.visibility = \"0\" !== c.properties.visibility);\n    const a = t.getAttribute(\"id\");\n    return null !== a && \"\" !== a && (c.id = a), c;\n  }\n  function X(t) {\n    if (r(t, \"gx:LatLonQuad\")) {\n      return {\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [z($(J(t)))]\n        }\n      };\n    }\n    return function (t) {\n      const e = r(t, \"LatLonBox\");\n      if (e) {\n        const t = a(e, \"north\"),\n          n = a(e, \"west\"),\n          o = a(e, \"east\"),\n          r = a(e, \"south\"),\n          i = a(e, \"rotation\");\n        if (\"number\" == typeof t && \"number\" == typeof r && \"number\" == typeof n && \"number\" == typeof o) {\n          const e = [n, r, o, t];\n          let s = [[[n, t], [o, t], [o, r], [n, r], [n, t]]];\n          return \"number\" == typeof i && (s = function (t, e, n) {\n            const o = [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2];\n            return [e[0].map(t => {\n              const e = t[1] - o[1],\n                r = t[0] - o[0],\n                i = Math.sqrt(Math.pow(e, 2) + Math.pow(r, 2)),\n                s = Math.atan2(e, r) + n * Y;\n              return [o[0] + Math.cos(s) * i, o[1] + Math.sin(s) * i];\n            })];\n          }(e, s, i)), {\n            bbox: e,\n            geometry: {\n              type: \"Polygon\",\n              coordinates: s\n            }\n          };\n        }\n      }\n      return null;\n    }(t);\n  }\n  const Y = Math.PI / 180;\n  function Z(t, e, n, o) {\n    const r = X(t),\n      i = r?.geometry || null;\n    if (!i && o.skipNullGeometry) return null;\n    const s = {\n      type: \"Feature\",\n      geometry: i,\n      properties: Object.assign({\n        \"@geometry-type\": \"groundoverlay\"\n      }, l(t, [\"name\", \"address\", \"visibility\", \"open\", \"phoneNumber\", \"description\"]), C(t), H(t, e), G(t), L(t), E(t, n), D(t), W(t))\n    };\n    r?.bbox && (s.bbox = r.bbox), void 0 !== s.properties?.visibility && (s.properties.visibility = \"0\" !== s.properties.visibility);\n    const c = t.getAttribute(\"id\");\n    return null !== c && \"\" !== c && (s.id = c), s;\n  }\n  function tt(t) {\n    let e = t.getAttribute(\"id\");\n    const o = t.parentNode;\n    return !e && u(o) && \"CascadingStyle\" === o.localName && (e = o.getAttribute(\"kml:id\") || o.getAttribute(\"id\")), n(e || \"\");\n  }\n  function et(t) {\n    const o = {};\n    for (const n of e(t, \"Style\")) o[tt(n)] = G(n);\n    for (const r of e(t, \"StyleMap\")) {\n      const t = n(r.getAttribute(\"id\") || \"\");\n      s(r, \"styleUrl\", e => {\n        e = n(e), o[e] && (o[t] = o[e]);\n      });\n    }\n    return o;\n  }\n  function nt(t) {\n    const n = {};\n    for (const o of e(t, \"SimpleField\")) n[o.getAttribute(\"name\") || \"\"] = B[o.getAttribute(\"type\") || \"\"] || B.string;\n    return n;\n  }\n  const ot = [\"name\", \"visibility\", \"open\", \"address\", \"description\", \"phoneNumber\", \"visibility\"];\n  function* rt(t, n = {\n    skipNullGeometry: !1\n  }) {\n    const o = et(t),\n      r = nt(t);\n    for (const i of e(t, \"Placemark\")) {\n      const t = K(i, o, r, n);\n      t && (yield t);\n    }\n    for (const i of e(t, \"GroundOverlay\")) {\n      const t = Z(i, o, r, n);\n      t && (yield t);\n    }\n  }\n  t.gpx = function (t) {\n    return {\n      type: \"FeatureCollection\",\n      features: Array.from(k(t))\n    };\n  }, t.gpxGen = k, t.kml = function (t, e = {\n    skipNullGeometry: !1\n  }) {\n    return {\n      type: \"FeatureCollection\",\n      features: Array.from(rt(t, e))\n    };\n  }, t.kmlGen = rt, t.kmlWithFolders = function (t, e = {\n    skipNullGeometry: !1\n  }) {\n    const n = et(t),\n      r = nt(t),\n      i = {\n        type: \"root\",\n        children: []\n      };\n    return function t(e, i, s) {\n      if (u(e)) switch (e.tagName) {\n        case \"GroundOverlay\":\n          {\n            const t = Z(e, n, r, s);\n            t && i.children.push(t);\n            break;\n          }\n        case \"Placemark\":\n          {\n            const t = K(e, n, r, s);\n            t && i.children.push(t);\n            break;\n          }\n        case \"Folder\":\n          {\n            const t = function (t) {\n              const e = {};\n              for (const n of Array.from(t.childNodes)) u(n) && ot.includes(n.tagName) && (e[n.tagName] = o(n));\n              return {\n                type: \"folder\",\n                meta: e,\n                children: []\n              };\n            }(e);\n            i.children.push(t), i = t;\n            break;\n          }\n      }\n      if (e.childNodes) for (let n = 0; n < e.childNodes.length; n++) t(e.childNodes[n], i, s);\n    }(t, i, e), i;\n  }, t.tcx = function (t) {\n    return {\n      type: \"FeatureCollection\",\n      features: Array.from(O(t))\n    };\n  }, t.tcxGen = O, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"names":["e","t","Array","from","getElementsByTagName","n","o","normalize","textContent","r","length","i","s","c","parseFloat","isNaN","a","l","u","nodeType","f","Object","assign","stroke","p","childNodes","g","nodeName","concat","push","d","includes","m","getAttribute","coordinates","time","extendedValues","h","getElementsByTagNameNS","parentNode","tagName","replace","links","map","href","y","fill","line","times","b","type","properties","_gpxType","geometry","N","coordinateProperties","entries","x","k","A","S","v","T","heartRate","extensions","F","extendedProperties","heartRates","P","fromEntries","name","heart","O","w","substring","parseInt","M","j","L","icon","G","R","Number","B","string","int","uint","short","ushort","float","double","bool","Boolean","E","C","description","value","D","timespan","begin","end","W","timestamp","H","styleUrl","_","I","U","V","split","filter","slice","$","q","z","Math","max","J","Q","item","geometries","coordTimes","K","skipNullGeometry","visibility","id","X","sqrt","pow","atan2","Y","cos","sin","bbox","PI","Z","tt","localName","et","nt","ot","rt","gpx","features","gpxGen","kml","kmlGen","kmlWithFolders","children","meta","tcx","tcxGen","defineProperty"],"sources":["../lib/lib/shared.ts","../lib/lib/gpx/line.ts","../lib/lib/gpx/extensions.ts","../lib/lib/gpx/coord_pair.ts","../lib/lib/gpx/properties.ts","../lib/lib/gpx.ts","../lib/lib/tcx.ts","../lib/lib/kml/fixColor.ts","../lib/lib/kml/extractStyle.ts","../lib/lib/kml/shared.ts","../lib/lib/kml/geometry.ts","../lib/lib/kml/placemark.ts","../lib/lib/kml/ground_overlay.ts","../lib/lib/kml.ts"],"sourcesContent":["import type { Feature, Geometry } from \"geojson\";\n\nexport function $(element: Element | Document, tagName: string): Element[] {\n  return Array.from(element.getElementsByTagName(tagName));\n}\n\nexport type P = NonNullable<Feature[\"properties\"]>;\nexport type F = Feature<Geometry | null>;\n\nexport type StyleMap = { [key: string]: P };\n\nexport function normalizeId(id: string) {\n  return id[0] === \"#\" ? id : `#${id}`;\n}\n\nexport function $ns(\n  element: Element | Document,\n  tagName: string,\n  ns: string\n): Element[] {\n  return Array.from(element.getElementsByTagNameNS(ns, tagName));\n}\n\n/**\n * get the content of a text node, if any\n */\nexport function nodeVal(node: Element | null) {\n  node?.normalize();\n  return (node && node.textContent) || \"\";\n}\n\n/**\n * Get one Y child of X, if any, otherwise null\n */\nexport function get1(\n  node: Element,\n  tagName: string,\n  callback?: (elem: Element) => unknown\n) {\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) callback(result);\n  return result;\n}\n\nexport function get(\n  node: Element | null,\n  tagName: string,\n  callback?: (elem: Element, properties: P) => P\n) {\n  const properties: Feature[\"properties\"] = {};\n  if (!node) return properties;\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) {\n    return callback(result, properties);\n  }\n  return properties;\n}\n\nexport function val1(\n  node: Element,\n  tagName: string,\n  callback: (val: string) => P | void\n): P {\n  const val = nodeVal(get1(node, tagName));\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function $num(\n  node: Element,\n  tagName: string,\n  callback: (val: number) => Feature[\"properties\"]\n) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function num1(\n  node: Element,\n  tagName: string,\n  callback?: (val: number) => unknown\n) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (callback) callback(val);\n  return val;\n}\n\nexport function getMulti(node: Element, propertyNames: string[]): P {\n  const properties: P = {};\n  for (const property of propertyNames) {\n    val1(node, property, (val) => {\n      properties[property] = val;\n    });\n  }\n  return properties;\n}\n\nexport function isElement(node: Node | null): node is Element {\n  return node?.nodeType === 1;\n}\n","import { get, P, val1, $num } from \"../shared\";\n\nexport function getLineStyle(node: Element | null) {\n  return get(node, \"line\", (lineStyle) => {\n    const val: P = Object.assign(\n      {},\n      val1(lineStyle, \"color\", (color) => {\n        return { stroke: `#${color}` };\n      }),\n      $num(lineStyle, \"opacity\", (opacity) => {\n        return { \"stroke-opacity\": opacity };\n      }),\n      $num(lineStyle, \"width\", (width) => {\n        // GPX width is in mm, convert to px with 96 px per inch\n        return { \"stroke-width\": (width * 96) / 25.4 };\n      })\n    );\n    return val;\n  });\n}\n","import { isElement, nodeVal } from \"../shared\";\n\nexport type ExtendedValues = [string, string | number][];\n\nexport function getExtensions(node: Element | null): ExtendedValues {\n  let values: [string, string | number][] = [];\n  if (node === null) return values;\n  for (const child of Array.from(node.childNodes)) {\n    if (!isElement(child)) continue;\n    const name = abbreviateName(child.nodeName);\n    if (name === \"gpxtpx:TrackPointExtension\") {\n      // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n      values = values.concat(getExtensions(child));\n    } else {\n      // push custom extension (eg. \"power\")\n      const val = nodeVal(child);\n      values.push([name, parseNumeric(val)]);\n    }\n  }\n  return values;\n}\n\nfunction abbreviateName(name: string) {\n  return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(name) ? \"heart\" : name;\n}\n\nfunction parseNumeric(val: string) {\n  const num = parseFloat(val);\n  return isNaN(num) ? val : num;\n}\n","import { Position } from \"geojson\";\nimport { num1, get1, nodeVal } from \"../shared\";\nimport { ExtendedValues, getExtensions } from \"./extensions\";\n\ninterface CoordPair {\n  coordinates: Position;\n  time: string | null;\n  extendedValues: ExtendedValues;\n}\n\nexport function coordPair(node: Element): CoordPair | null {\n  const ll = [\n    parseFloat(node.getAttribute(\"lon\") || \"\"),\n    parseFloat(node.getAttribute(\"lat\") || \"\"),\n  ];\n\n  if (isNaN(ll[0]) || isNaN(ll[1])) {\n    return null;\n  }\n\n  num1(node, \"ele\", (val) => {\n    ll.push(val);\n  });\n\n  const time = get1(node, \"time\");\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: getExtensions(get1(node, \"extensions\")),\n  };\n}\n","import { $, getMulti, nodeVal } from \"../shared\";\n\nexport function extractProperties(node: Element) {\n  const properties = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n\n  const extensions = Array.from(\n    node.getElementsByTagNameNS(\n      \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n      \"*\"\n    )\n  );\n  for (const child of extensions) {\n    if (child.parentNode?.parentNode === node) {\n      properties[child.tagName.replace(\":\", \"_\")] = nodeVal(child);\n    }\n  }\n\n  const links = $(node, \"link\");\n  if (links.length) {\n    properties.links = links.map((link) =>\n      Object.assign(\n        { href: link.getAttribute(\"href\") },\n        getMulti(link, [\"text\", \"type\"])\n      )\n    );\n  }\n\n  return properties;\n}\n","import type {\n  FeatureCollection,\n  Feature,\n  Point,\n  MultiLineString,\n  LineString,\n  Position,\n} from \"geojson\";\nimport { getLineStyle } from \"./gpx/line\";\nimport { coordPair } from \"./gpx/coord_pair\";\nimport { extractProperties } from \"./gpx/properties\";\nimport { P, $, get1, getMulti } from \"./shared\";\n\n/**\n * Extract points from a trkseg or rte element.\n */\nfunction getPoints(node: Element, pointname: \"trkpt\" | \"rtept\") {\n  const pts = $(node, pointname);\n  const line: Position[] = [];\n  const times = [];\n  const extendedValues: P = {};\n\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (!c) {\n      continue;\n    }\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (const [name, val] of c.extendedValues) {\n      const plural =\n        name === \"heart\" ? name : name.replace(\"gpxtpx:\", \"\") + \"s\";\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n\n  if (line.length < 2) return; // Invalid line in GeoJSON\n\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues,\n  };\n}\n\n/**\n * Extract a LineString geometry from a rte\n * element.\n */\nfunction getRoute(node: Element): Feature<LineString> | undefined {\n  const line = getPoints(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      { _gpxType: \"rte\" },\n      extractProperties(node),\n      getLineStyle(get1(node, \"extensions\"))\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getTrack(node: Element): Feature<LineString | MultiLineString> | null {\n  const segments = $(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n\n  for (const segment of segments) {\n    const line = getPoints(segment, \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times && line.times.length) times.push(line.times);\n    }\n  }\n\n  if (extractedLines.length === 0) return null;\n\n  const multi = extractedLines.length > 1;\n\n  const properties: Feature[\"properties\"] = Object.assign(\n    { _gpxType: \"trk\" },\n    extractProperties(node),\n    getLineStyle(get1(node, \"extensions\")),\n    times.length\n      ? {\n          coordinateProperties: {\n            times: multi ? times : times[0],\n          },\n        }\n      : {}\n  );\n\n  for (const line of extractedLines) {\n    track.push(line.line);\n    if (!properties.coordinateProperties) {\n      properties.coordinateProperties = {};\n    }\n    const props = properties.coordinateProperties;\n    const entries = Object.entries(line.extendedValues);\n    for (let i = 0; i < entries.length; i++) {\n      const [name, val] = entries[i];\n      if (multi) {\n        if (!props[name]) {\n          props[name] = extractedLines.map((line) =>\n            new Array(line.line.length).fill(null)\n          );\n        }\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi\n      ? {\n          type: \"MultiLineString\",\n          coordinates: track,\n        }\n      : {\n          type: \"LineString\",\n          coordinates: track[0],\n        },\n  };\n}\n\n/**\n * Extract a point, if possible, from a given node,\n * which is usually a wpt or trkpt\n */\nfunction getPoint(node: Element): Feature<Point> | null {\n  const properties: Feature[\"properties\"] = Object.assign(\n    extractProperties(node),\n    getMulti(node, [\"sym\"])\n  );\n  const pair = coordPair(node);\n  if (!pair) return null;\n  return {\n    type: \"Feature\",\n    properties,\n    geometry: {\n      type: \"Point\",\n      coordinates: pair.coordinates,\n    },\n  };\n}\n\n/**\n * Convert GPX to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* gpxGen(node: Document): Generator<Feature> {\n  for (const track of $(node, \"trk\")) {\n    const feature = getTrack(track);\n    if (feature) yield feature;\n  }\n\n  for (const route of $(node, \"rte\")) {\n    const feature = getRoute(route);\n    if (feature) yield feature;\n  }\n\n  for (const waypoint of $(node, \"wpt\")) {\n    const point = getPoint(waypoint);\n    if (point) yield point;\n  }\n}\n\n/**\n *\n * Convert a GPX document to GeoJSON. The first argument, `doc`, must be a GPX\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data, same as `.kml` outputs, with the\n * addition of a `_gpxType` property on each `LineString` feature that indicates whether\n * the feature was encoded as a route (`rte`) or track (`trk`) in the GPX document.\n */\nexport function gpx(node: Document): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(node)),\n  };\n}\n","import { Feature, FeatureCollection, Position } from \"geojson\";\nimport { P, $, get, num1, nodeVal, get1 } from \"./shared\";\n\ntype PropertyMapping = readonly [string, string][];\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\n\nconst TRACKPOINT_ATTRIBUTES: PropertyMapping = [\n  [\"heartRate\", \"heartRates\"],\n  [\"Cadence\", \"cadences\"],\n  // Extended Trackpoint attributes\n  [\"Speed\", \"speeds\"],\n  [\"Watts\", \"watts\"],\n];\n\nconst LAP_ATTRIBUTES: PropertyMapping = [\n  [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n  [\"DistanceMeters\", \"distanceMeters\"],\n  [\"MaximumSpeed\", \"maxSpeed\"],\n  [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n  [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n\n  // Extended Lap attributes\n  [\"AvgSpeed\", \"avgSpeed\"],\n  [\"AvgWatts\", \"avgWatts\"],\n  [\"MaxWatts\", \"maxWatts\"],\n];\n\nfunction getProperties(node: Element, attributeNames: PropertyMapping) {\n  const properties = [];\n\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = parseFloat(nodeVal(elem));\n    if (!isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n\n  return properties;\n}\n\nfunction coordPair(node: Element) {\n  const ll = [num1(node, \"LongitudeDegrees\"), num1(node, \"LatitudeDegrees\")];\n  if (\n    ll[0] === undefined ||\n    isNaN(ll[0]) ||\n    ll[1] === undefined ||\n    isNaN(ll[1])\n  ) {\n    return null;\n  }\n  const heartRate = get1(node, \"HeartRateBpm\");\n  const time = nodeVal(get1(node, \"Time\"));\n  get1(node, \"AltitudeMeters\", (alt) => {\n    const a = parseFloat(nodeVal(alt));\n    if (!isNaN(a)) {\n      ll.push(a);\n    }\n  });\n  return {\n    coordinates: ll as number[],\n    time: time || null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(node, TRACKPOINT_ATTRIBUTES),\n  };\n}\n\nfunction getPoints(node: Element) {\n  const pts = $(node, \"Trackpoint\");\n  const line: Position[] = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const extendedProperties: P = {};\n  const result = { extendedProperties };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    const { time, heartRate, extensions } = c;\n    if (time) times.push(time);\n    if (heartRate) heartRates.push(heartRate);\n    for (const [alias, value] of extensions) {\n      if (!extendedProperties[alias]) {\n        extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      extendedProperties[alias][i] = value;\n    }\n  }\n  if (line.length < 2) return null;\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates,\n  });\n}\n\nfunction getLap(node: Element): Feature | null {\n  const segments = $(node, \"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line;\n  const properties: P = Object.assign(\n    Object.fromEntries(getProperties(node, LAP_ATTRIBUTES)),\n    get(node, \"Name\", (nameElement) => {\n      return { name: nodeVal(nameElement) };\n    })\n  );\n\n  for (const segment of segments) {\n    line = getPoints(segment);\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        if (line) {\n          properties[property] = line.extendedProperties[property];\n        }\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map((track) =>\n            Array(track.length).fill(null)\n          );\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n\n  if (track.length === 0) return null;\n\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(\n      times.length\n        ? {\n            times: track.length === 1 ? times[0] : times,\n          }\n        : {},\n      heartRates.length\n        ? {\n            heart: track.length === 1 ? heartRates[0] : heartRates,\n          }\n        : {}\n    );\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry:\n      track.length === 1\n        ? {\n            type: \"LineString\",\n            coordinates: track[0],\n          }\n        : {\n            type: \"MultiLineString\",\n            coordinates: track,\n          },\n  };\n}\n\n/**\n * Incrementally convert a TCX document to GeoJSON. The\n * first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function* tcxGen(node: Document): Generator<Feature> {\n  for (const lap of $(node, \"Lap\")) {\n    const feature = getLap(lap);\n    if (feature) yield feature;\n  }\n\n  for (const course of $(node, \"Courses\")) {\n    const feature = getLap(course);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a TCX document to GeoJSON. The first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function tcx(node: Document): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(node)),\n  };\n}\n","import { P } from \"../shared\";\n\nexport function fixColor(v: string, prefix: string): P {\n  const properties: P = {};\n  const colorProp =\n    prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v[0] === \"#\") {\n    v = v.substring(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = \"#\" + v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substring(0, 2), 16) / 255;\n    properties[colorProp] =\n      \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return properties;\n}\n","import { P, get, num1, nodeVal, val1 } from \"../shared\";\nimport { fixColor } from \"./fixColor\";\n\nfunction numericProperty(node: Element, source: string, target: string): P {\n  const properties: P = {};\n  num1(node, source, (val) => {\n    properties[target] = val;\n  });\n  return properties;\n}\n\nfunction getColor(node: Element, output: string): P {\n  return get(node, \"color\", (elem) => fixColor(nodeVal(elem), output));\n}\n\nexport function extractIconHref(node: Element) {\n  return get(node, \"Icon\", (icon, properties) => {\n    val1(icon, \"href\", (href) => {\n      properties.icon = href;\n    });\n    return properties;\n  });\n}\n\nexport function extractIcon(node: Element) {\n  return get(node, \"IconStyle\", (iconStyle) => {\n    return Object.assign(\n      getColor(iconStyle, \"icon\"),\n      numericProperty(iconStyle, \"scale\", \"icon-scale\"),\n      numericProperty(iconStyle, \"heading\", \"icon-heading\"),\n      get(iconStyle, \"hotSpot\", (hotspot) => {\n        const left = parseFloat(hotspot.getAttribute(\"x\") || \"\");\n        const top = parseFloat(hotspot.getAttribute(\"y\") || \"\");\n        const xunits = hotspot.getAttribute(\"xunits\") || \"\";\n        const yunits = hotspot.getAttribute(\"yunits\") || \"\";\n        if (!isNaN(left) && !isNaN(top))\n          return {\n            \"icon-offset\": [left, top],\n            \"icon-offset-units\": [xunits, yunits],\n          };\n        return {};\n      }),\n      extractIconHref(iconStyle)\n    );\n  });\n}\n\nexport function extractLabel(node: Element) {\n  return get(node, \"LabelStyle\", (labelStyle) => {\n    return Object.assign(\n      getColor(labelStyle, \"label\"),\n      numericProperty(labelStyle, \"scale\", \"label-scale\")\n    );\n  });\n}\n\nexport function extractLine(node: Element) {\n  return get(node, \"LineStyle\", (lineStyle) => {\n    return Object.assign(\n      getColor(lineStyle, \"stroke\"),\n      numericProperty(lineStyle, \"width\", \"stroke-width\")\n    );\n  });\n}\n\nexport function extractPoly(node: Element) {\n  return get(node, \"PolyStyle\", (polyStyle, properties) => {\n    return Object.assign(\n      properties,\n      get(polyStyle, \"color\", (elem) => fixColor(nodeVal(elem), \"fill\")),\n      val1(polyStyle, \"fill\", (fill) => {\n        if (fill === \"0\") return { \"fill-opacity\": 0 };\n      }),\n      val1(polyStyle, \"outline\", (outline) => {\n        if (outline === \"0\") return { \"stroke-opacity\": 0 };\n      })\n    );\n  });\n}\n\nexport function extractStyle(node: Element) {\n  return Object.assign(\n    {},\n    extractPoly(node),\n    extractLine(node),\n    extractLabel(node),\n    extractIcon(node)\n  );\n}\n","import {\n  get,\n  get1,\n  nodeVal,\n  $,\n  normalizeId,\n  P,\n  StyleMap,\n  val1,\n} from \"../shared\";\n\nexport type TypeConverter = (x: string) => unknown;\nexport type Schema = { [key: string]: TypeConverter };\n\nconst toNumber: TypeConverter = (x) => Number(x);\nexport const typeConverters: Record<string, TypeConverter> = {\n  string: (x) => x,\n  int: toNumber,\n  uint: toNumber,\n  short: toNumber,\n  ushort: toNumber,\n  float: toNumber,\n  double: toNumber,\n  bool: (x) => Boolean(x),\n};\n\nexport function extractExtendedData(node: Element, schema: Schema) {\n  return get(node, \"ExtendedData\", (extendedData, properties) => {\n    for (const data of $(extendedData, \"Data\")) {\n      properties[data.getAttribute(\"name\") || \"\"] = nodeVal(\n        get1(data, \"value\")\n      );\n    }\n    for (const simpleData of $(extendedData, \"SimpleData\")) {\n      const name = simpleData.getAttribute(\"name\") || \"\";\n      const typeConverter = schema[name] || typeConverters.string;\n      properties[name] = typeConverter(nodeVal(simpleData));\n    }\n    return properties;\n  });\n}\n\nexport function getMaybeHTMLDescription(node: Element) {\n  const descriptionNode = get1(node, \"description\");\n  for (const c of Array.from(descriptionNode?.childNodes || [])) {\n    if (c.nodeType === 4) {\n      return {\n        description: {\n          \"@type\": \"html\",\n          value: nodeVal(c as Element),\n        },\n      };\n    }\n  }\n  return {};\n}\n\nexport function extractTimeSpan(node: Element): P {\n  return get(node, \"TimeSpan\", (timeSpan) => {\n    return {\n      timespan: {\n        begin: nodeVal(get1(timeSpan, \"begin\")),\n        end: nodeVal(get1(timeSpan, \"end\")),\n      },\n    };\n  });\n}\n\nexport function extractTimeStamp(node: Element): P {\n  return get(node, \"TimeStamp\", (timeStamp) => {\n    return { timestamp: nodeVal(get1(timeStamp, \"when\")) };\n  });\n}\n\nexport function extractCascadedStyle(node: Element, styleMap: StyleMap): P {\n  return val1(node, \"styleUrl\", (styleUrl) => {\n    styleUrl = normalizeId(styleUrl);\n    if (styleMap[styleUrl]) {\n      return Object.assign({ styleUrl }, styleMap[styleUrl]);\n    }\n    // For backward-compatibility. Should we still include\n    // styleUrl even if it's not resolved?\n    return { styleUrl };\n  });\n}\n","import { Position, Point, LineString, Geometry } from \"geojson\";\nimport { $, $ns, nodeVal, get1, isElement } from \"../shared\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n/**\n * Get one coordinate from a coordinate array, if any\n */\nexport function coord1(value: string): Position {\n  return value\n    .replace(removeSpace, \"\")\n    .split(\",\")\n    .map(parseFloat)\n    .filter((num) => !isNaN(num))\n    .slice(0, 3);\n}\n\n/**\n * Get all coordinates from a coordinate array as [[],[]]\n */\nexport function coord(value: string): Position[] {\n  return value\n    .replace(trimSpace, \"\")\n    .split(splitSpace)\n    .map(coord1)\n    .filter((coord) => {\n      return coord.length >= 2;\n    });\n}\n\nfunction gxCoords(\n  node: Element\n): { geometry: Point | LineString; times: string[] } | null {\n  let elems = $(node, \"coord\");\n  if (elems.length === 0) {\n    elems = $ns(node, \"coord\", \"*\");\n  }\n\n  const coordinates = elems.map((elem) => {\n    return nodeVal(elem).split(\" \").map(parseFloat);\n  });\n\n  if (coordinates.length === 0) {\n    return null;\n  }\n\n  return {\n    geometry:\n      coordinates.length > 2\n        ? {\n            type: \"LineString\",\n            coordinates,\n          }\n        : {\n            type: \"Point\",\n            coordinates: coordinates[0],\n          },\n    times: $(node, \"when\").map((elem) => nodeVal(elem)),\n  };\n}\n\nexport function fixRing(ring: Position[]) {\n  if (ring.length === 0) return ring;\n  const first = ring[0];\n  const last = ring[ring.length - 1];\n  let equal = true;\n  for (let i = 0; i < Math.max(first.length, last.length); i++) {\n    if (first[i] !== last[i]) {\n      equal = false;\n      break;\n    }\n  }\n  if (!equal) {\n    return ring.concat([ring[0]]);\n  }\n  return ring;\n}\n\nexport function getCoordinates(node: Element) {\n  return nodeVal(get1(node, \"coordinates\"));\n}\n\ninterface GeometriesAndTimes {\n  geometries: Geometry[];\n  coordTimes: string[][];\n}\n\nexport function getGeometry(node: Element): GeometriesAndTimes {\n  let geometries: Geometry[] = [];\n  let coordTimes: string[][] = [];\n\n  for (let i = 0; i < node.childNodes.length; i++) {\n    const child = node.childNodes.item(i);\n    if (isElement(child)) {\n      switch (child.tagName) {\n        case \"MultiGeometry\":\n        case \"MultiTrack\":\n        case \"gx:MultiTrack\": {\n          const childGeometries = getGeometry(child);\n          geometries = geometries.concat(childGeometries.geometries);\n          coordTimes = coordTimes.concat(childGeometries.coordTimes);\n          break;\n        }\n\n        case \"Point\": {\n          const coordinates = coord1(getCoordinates(child));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"Point\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"LinearRing\":\n        case \"LineString\": {\n          const coordinates = coord(getCoordinates(child));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"LineString\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"Polygon\": {\n          const coords = [];\n          for (const linearRing of $(child, \"LinearRing\")) {\n            const ring = fixRing(coord(getCoordinates(linearRing)));\n            if (ring.length >= 4) {\n              coords.push(ring);\n            }\n          }\n          if (coords.length) {\n            geometries.push({\n              type: \"Polygon\",\n              coordinates: coords,\n            });\n          }\n          break;\n        }\n        case \"Track\":\n        case \"gx:Track\": {\n          const gx = gxCoords(child);\n          if (!gx) break;\n          const { times, geometry } = gx;\n          geometries.push(geometry);\n          if (times.length) coordTimes.push(times);\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    geometries,\n    coordTimes,\n  };\n}\n","import { Feature, Geometry } from \"geojson\";\nimport { StyleMap, getMulti } from \"../shared\";\nimport {\n  extractCascadedStyle,\n  extractExtendedData,\n  extractTimeSpan,\n  extractTimeStamp,\n  getMaybeHTMLDescription,\n  Schema,\n} from \"./shared\";\nimport { extractStyle } from \"./extractStyle\";\nimport { getGeometry } from \"./geometry\";\nimport { KMLOptions } from \"lib/kml\";\n\nfunction geometryListToGeometry(geometries: Geometry[]): Geometry | null {\n  return geometries.length === 0\n    ? null\n    : geometries.length === 1\n    ? geometries[0]\n    : {\n        type: \"GeometryCollection\",\n        geometries,\n      };\n}\n\nexport function getPlacemark(\n  node: Element,\n  styleMap: StyleMap,\n  schema: Schema,\n  options: KMLOptions\n): Feature<Geometry | null> | null {\n  const { coordTimes, geometries } = getGeometry(node);\n\n  const geometry = geometryListToGeometry(geometries);\n\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n\n  const feature: Feature<Geometry | null> = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractExtendedData(node, schema),\n      extractTimeSpan(node),\n      extractTimeStamp(node),\n      coordTimes.length\n        ? {\n            coordinateProperties: {\n              times: coordTimes.length === 1 ? coordTimes[0] : coordTimes,\n            },\n          }\n        : {}\n    ),\n  };\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n","import { Feature, Polygon } from \"geojson\";\nimport { StyleMap, get1, num1, getMulti } from \"../shared\";\nimport {\n  extractCascadedStyle,\n  extractExtendedData,\n  extractTimeSpan,\n  extractTimeStamp,\n  getMaybeHTMLDescription,\n  Schema,\n} from \"./shared\";\nimport { extractIconHref, extractStyle } from \"./extractStyle\";\nimport { coord, fixRing, getCoordinates } from \"./geometry\";\nimport { KMLOptions } from \"lib/kml\";\n\ninterface BoxGeometry {\n  bbox?: BBox;\n  geometry: Polygon;\n}\n\nfunction getGroundOverlayBox(node: Element): BoxGeometry | null {\n  const latLonQuad = get1(node, \"gx:LatLonQuad\");\n\n  if (latLonQuad) {\n    const ring = fixRing(coord(getCoordinates(node)));\n    return {\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [ring],\n      },\n    };\n  }\n\n  return getLatLonBox(node);\n}\n\ntype BBox = [number, number, number, number];\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nfunction rotateBox(\n  bbox: BBox,\n  coordinates: Polygon[\"coordinates\"],\n  rotation: number\n): Polygon[\"coordinates\"] {\n  const center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n\n  return [\n    coordinates[0].map((coordinate) => {\n      const dy = coordinate[1] - center[1];\n      const dx = coordinate[0] - center[0];\n      const distance = Math.sqrt(Math.pow(dy, 2) + Math.pow(dx, 2));\n      const angle = Math.atan2(dy, dx) + rotation * DEGREES_TO_RADIANS;\n\n      return [\n        center[0] + Math.cos(angle) * distance,\n        center[1] + Math.sin(angle) * distance,\n      ];\n    }),\n  ];\n}\n\nfunction getLatLonBox(node: Element): BoxGeometry | null {\n  const latLonBox = get1(node, \"LatLonBox\");\n\n  if (latLonBox) {\n    const north = num1(latLonBox, \"north\");\n    const west = num1(latLonBox, \"west\");\n    const east = num1(latLonBox, \"east\");\n    const south = num1(latLonBox, \"south\");\n    const rotation = num1(latLonBox, \"rotation\");\n\n    if (\n      typeof north === \"number\" &&\n      typeof south === \"number\" &&\n      typeof west === \"number\" &&\n      typeof east === \"number\"\n    ) {\n      const bbox: BBox = [west, south, east, north];\n      let coordinates = [\n        [\n          [west, north], // top left\n          [east, north], // top right\n          [east, south], // top right\n          [west, south], // bottom left\n          [west, north], // top left (again)\n        ],\n      ];\n      if (typeof rotation === \"number\") {\n        coordinates = rotateBox(bbox, coordinates, rotation);\n      }\n      return {\n        bbox,\n        geometry: {\n          type: \"Polygon\",\n          coordinates,\n        },\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function getGroundOverlay(\n  node: Element,\n  styleMap: StyleMap,\n  schema: Schema,\n  options: KMLOptions\n): Feature<Polygon | null> | null {\n  const box = getGroundOverlayBox(node);\n\n  const geometry = box?.geometry || null;\n\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n\n  const feature: Feature<Polygon | null> = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n      /**\n       * Related to\n       * https://gist.github.com/tmcw/037a1cb6660d74a392e9da7446540f46\n       */\n      { \"@geometry-type\": \"groundoverlay\" },\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractIconHref(node),\n      extractExtendedData(node, schema),\n      extractTimeSpan(node),\n      extractTimeStamp(node)\n    ),\n  };\n\n  if (box?.bbox) {\n    feature.bbox = box.bbox;\n  }\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n","import { extractStyle } from \"./kml/extractStyle\";\nimport { getPlacemark } from \"./kml/placemark\";\nimport { getGroundOverlay } from \"./kml/ground_overlay\";\nimport { FeatureCollection, Geometry } from \"geojson\";\nimport {\n  $,\n  StyleMap,\n  P,\n  F,\n  val1,\n  nodeVal,\n  isElement,\n  normalizeId,\n} from \"./shared\";\nimport { Schema, typeConverters } from \"./kml/shared\";\n\n/**\n * Options to customize KML output.\n *\n * The only option currently\n * is `skipNullGeometry`. Both the KML and GeoJSON formats support\n * the idea of features that don't have geometries: in KML,\n * this is a Placemark without a Point, etc element, and in GeoJSON\n * it's a geometry member with a value of `null`.\n *\n * toGeoJSON, by default, translates null geometries in KML to\n * null geometries in GeoJSON. For systems that use GeoJSON but\n * don't support null geometries, you can specify `skipNullGeometry`\n * to omit these features entirely and only include\n * features that have a geometry defined.\n */\nexport interface KMLOptions {\n  skipNullGeometry?: boolean;\n}\n\n/**\n * A folder including metadata. Folders\n * may contain other folders or features,\n * or nothing at all.\n */\nexport interface Folder {\n  type: \"folder\";\n  /**\n   * Standard values:\n   *\n   * * \"name\",\n   * * \"visibility\",\n   * * \"open\",\n   * * \"address\",\n   * * \"description\",\n   * * \"phoneNumber\",\n   * * \"visibility\",\n   */\n  meta: {\n    [key: string]: unknown;\n  };\n  children: Array<Folder | F>;\n}\n\n/**\n * A nested folder structure, represented\n * as a tree with folders and features.\n */\nexport interface Root {\n  type: \"root\";\n  children: Array<Folder | F>;\n}\n\ntype TreeContainer = Root | Folder;\n\nfunction getStyleId(style: Element) {\n  let id = style.getAttribute(\"id\");\n  const parentNode = style.parentNode;\n  if (\n    !id &&\n    isElement(parentNode) &&\n    parentNode.localName === \"CascadingStyle\"\n  ) {\n    id = parentNode.getAttribute(\"kml:id\") || parentNode.getAttribute(\"id\");\n  }\n  return normalizeId(id || \"\");\n}\n\nfunction buildStyleMap(node: Document): StyleMap {\n  const styleMap: StyleMap = {};\n  for (const style of $(node, \"Style\")) {\n    styleMap[getStyleId(style)] = extractStyle(style);\n  }\n  for (const map of $(node, \"StyleMap\")) {\n    const id = normalizeId(map.getAttribute(\"id\") || \"\");\n    val1(map, \"styleUrl\", (styleUrl) => {\n      styleUrl = normalizeId(styleUrl);\n      if (styleMap[styleUrl]) {\n        styleMap[id] = styleMap[styleUrl];\n      }\n    });\n  }\n  return styleMap;\n}\n\nfunction buildSchema(node: Document): Schema {\n  const schema: Schema = {};\n  for (const field of $(node, \"SimpleField\")) {\n    schema[field.getAttribute(\"name\") || \"\"] =\n      typeConverters[field.getAttribute(\"type\") || \"\"] ||\n      typeConverters[\"string\"];\n  }\n  return schema;\n}\n\nconst FOLDER_PROPS = [\n  \"name\",\n  \"visibility\",\n  \"open\",\n  \"address\",\n  \"description\",\n  \"phoneNumber\",\n  \"visibility\",\n] as const;\n\nfunction getFolder(node: Element): Folder {\n  const meta: P = {};\n\n  for (const child of Array.from(node.childNodes)) {\n    if (isElement(child) && FOLDER_PROPS.includes(child.tagName as any)) {\n      meta[child.tagName] = nodeVal(child);\n    }\n  }\n\n  return {\n    type: \"folder\",\n    meta,\n    children: [],\n  };\n}\n\n/**\n * Yield a nested tree with KML folder structure\n *\n * This generates a tree with the given structure:\n *\n * ```js\n * {\n *   \"type\": \"root\",\n *   \"children\": [\n *     {\n *       \"type\": \"folder\",\n *       \"meta\": {\n *         \"name\": \"Test\"\n *       },\n *       \"children\": [\n *          // ...features and folders\n *       ]\n *     }\n *     // ...features\n *   ]\n * }\n * ```\n *\n * ### GroundOverlay\n *\n * GroundOverlay elements are converted into\n * `Feature` objects with `Polygon` geometries,\n * a property like:\n *\n * ```json\n * {\n *   \"@geometry-type\": \"groundoverlay\"\n * }\n * ```\n *\n * And the ground overlay's image URL in the `href`\n * property. Ground overlays will need to be displayed\n * with a separate method to other features, depending\n * on which map framework you're using.\n */\nexport function kmlWithFolders(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): Root {\n  const styleMap = buildStyleMap(node);\n  const schema = buildSchema(node);\n\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = [];\n  const tree: Root = { type: \"root\", children: [] };\n\n  function traverse(\n    node: Document | ChildNode | Element,\n    pointer: TreeContainer,\n    options: KMLOptions\n  ) {\n    if (isElement(node)) {\n      switch (node.tagName) {\n        case \"GroundOverlay\": {\n          placemarks.push(node);\n          const placemark = getGroundOverlay(node, styleMap, schema, options);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Placemark\": {\n          placemarks.push(node);\n          const placemark = getPlacemark(node, styleMap, schema, options);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Folder\": {\n          const folder = getFolder(node);\n          pointer.children.push(folder);\n          pointer = folder;\n          break;\n        }\n      }\n    }\n\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        traverse(node.childNodes[i], pointer, options);\n      }\n    }\n  }\n\n  traverse(node, tree, options);\n\n  return tree;\n}\n\n/**\n * Convert KML to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* kmlGen(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): Generator<F> {\n  const styleMap = buildStyleMap(node);\n  const schema = buildSchema(node);\n  for (const placemark of $(node, \"Placemark\")) {\n    const feature = getPlacemark(placemark, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n  for (const groundOverlay of $(node, \"GroundOverlay\")) {\n    const feature = getGroundOverlay(groundOverlay, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a KML document to GeoJSON. The first argument, `doc`, must be a KML\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data. You can convert it to a string\n * with [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * or use it directly in libraries.\n */\nexport function kml(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): FeatureCollection<Geometry | null> {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(node, options)),\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}