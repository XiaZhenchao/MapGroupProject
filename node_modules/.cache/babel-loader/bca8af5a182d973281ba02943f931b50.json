{"ast":null,"code":"var shp = require(\"./shp\"),\n  dbf = require(\"./dbf\");\nexports.version = require(\"./package.json\").version;\nexports.read = read;\nexports.reader = reader;\nvar readInternal = require(\"./read\")(reader);\nfunction read(filename, options, callback) {\n  if (arguments.length < 3) callback = options, options = null;\n  readInternal(filename, options, function (error, header, records) {\n    if (error) return callback(error);\n    callback(null, {\n      type: \"FeatureCollection\",\n      bbox: header.bbox,\n      features: records\n    });\n  });\n}\nfunction reader(filename, options) {\n  var convertProperties,\n    convertGeometry,\n    encoding = null,\n    ignoreProperties = false,\n    dbfReader,\n    shpReader;\n  if (typeof options === \"string\") options = {\n    encoding: options\n  };\n  if (options) \"encoding\" in options && (encoding = options[\"encoding\"]), \"ignore-properties\" in options && (ignoreProperties = !!options[\"ignore-properties\"]);\n  if (/\\.shp$/.test(filename)) filename = filename.substring(0, filename.length - 4);\n  if (!ignoreProperties) dbfReader = dbf.reader(filename + \".dbf\", encoding);\n  shpReader = shp.reader(filename + \".shp\");\n  function readHeader(callback) {\n    dbfReader.readHeader(function (error, header) {\n      if (header === end) error = new Error(\"unexpected EOF\");\n      if (error) return callback(error);\n      convertProperties = new Function(\"d\", \"return {\" + header.fields.map(function (field, i) {\n        return JSON.stringify(field.name) + \":d[\" + i + \"]\";\n      }) + \"};\");\n      readShpHeader(callback);\n    });\n    return this;\n  }\n  function readShpHeader(callback) {\n    shpReader.readHeader(function (error, header) {\n      if (header === end) error = new Error(\"unexpected EOF\");\n      if (error) return callback(error);\n      convertGeometry = convertGeometryTypes[header.shapeType];\n      callback(null, {\n        bbox: header.box\n      });\n    });\n    return this;\n  }\n  function readRecord(callback) {\n    dbfReader.readRecord(function (error, dbfRecord) {\n      if (dbfRecord === end) return callback(null, end);\n      if (error) return callback(error);\n      shpReader.readRecord(function (error, shpRecord) {\n        if (shpRecord === end) error = new Error(\"unexpected EOF\");\n        if (error) return callback(error);\n        callback(null, {\n          type: \"Feature\",\n          properties: convertProperties(dbfRecord),\n          geometry: shpRecord == null ? null : convertGeometry(shpRecord)\n        });\n      });\n    });\n    return this;\n  }\n  function readShpRecord(callback) {\n    shpReader.readRecord(function (error, shpRecord) {\n      if (shpRecord === end) return callback(null, end);\n      if (error) return callback(error);\n      callback(null, {\n        type: \"Feature\",\n        properties: {},\n        geometry: shpRecord == null ? null : convertGeometry(shpRecord)\n      });\n    });\n    return this;\n  }\n  function close(callback) {\n    dbfReader.close(function (error) {\n      if (error) return callback(error);\n      closeShp(callback);\n    });\n    return this;\n  }\n  function closeShp(callback) {\n    shpReader.close(callback);\n    return this;\n  }\n  return dbfReader ? {\n    readHeader: readHeader,\n    readRecord: readRecord,\n    close: close\n  } : {\n    readHeader: readShpHeader,\n    readRecord: readShpRecord,\n    close: closeShp\n  };\n}\nvar end = exports.end = shp.end;\nvar convertGeometryTypes = {\n  1: convertPoint,\n  3: convertPolyLine,\n  5: convertPolygon,\n  8: convertMultiPoint,\n  11: convertPoint,\n  // PointZ\n  13: convertPolyLine,\n  // PolyLineZ\n  15: convertPolygon,\n  // PolygonZ\n  18: convertMultiPoint // MultiPointZ\n};\n\nfunction readEmptyNextProperties(callback) {\n  callback(null, {});\n}\nfunction convertPoint(record) {\n  return {\n    type: \"Point\",\n    coordinates: [record.x, record.y]\n  };\n}\nfunction convertPolyLine(record) {\n  return record.parts.length === 1 ? {\n    type: \"LineString\",\n    coordinates: record.points\n  } : {\n    type: \"MultiLineString\",\n    coordinates: record.parts.map(function (i, j) {\n      return record.points.slice(i, record.parts[j + 1]);\n    })\n  };\n}\nfunction convertPolygon(record) {\n  var parts = record.parts.map(function (i, j) {\n      return record.points.slice(i, record.parts[j + 1]);\n    }),\n    polygons = [],\n    holes = [];\n  parts.forEach(function (part) {\n    if (ringClockwise(part)) polygons.push([part]);else holes.push(part);\n  });\n  holes.forEach(function (hole) {\n    var point = hole[0];\n    polygons.some(function (polygon) {\n      if (ringContains(polygon[0], point)) {\n        polygon.push(hole);\n        return true;\n      }\n    }) || polygons.push([hole]);\n  });\n  return polygons.length > 1 ? {\n    type: \"MultiPolygon\",\n    coordinates: polygons\n  } : {\n    type: \"Polygon\",\n    coordinates: polygons[0]\n  };\n}\nfunction convertMultiPoint(record) {\n  return {\n    type: \"MultiPoint\",\n    coordinates: record.points\n  };\n}\nfunction ringClockwise(ring) {\n  if ((n = ring.length) < 4) return false;\n  var i = 0,\n    n,\n    area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area >= 0;\n}\nfunction ringContains(ring, point) {\n  var x = point[0],\n    y = point[1],\n    contains = false;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i],\n      xi = pi[0],\n      yi = pi[1],\n      pj = ring[j],\n      xj = pj[0],\n      yj = pj[1];\n    if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;\n  }\n  return contains;\n}","map":{"version":3,"names":["shp","require","dbf","exports","version","read","reader","readInternal","filename","options","callback","arguments","length","error","header","records","type","bbox","features","convertProperties","convertGeometry","encoding","ignoreProperties","dbfReader","shpReader","test","substring","readHeader","end","Error","Function","fields","map","field","i","JSON","stringify","name","readShpHeader","convertGeometryTypes","shapeType","box","readRecord","dbfRecord","shpRecord","properties","geometry","readShpRecord","close","closeShp","convertPoint","convertPolyLine","convertPolygon","convertMultiPoint","readEmptyNextProperties","record","coordinates","x","y","parts","points","j","slice","polygons","holes","forEach","part","ringClockwise","push","hole","point","some","polygon","ringContains","ring","n","area","contains","pi","xi","yi","pj","xj","yj"],"sources":["/Users/yongerfan/Desktop/GroupProject/MapGroupProject/node_modules/shapefile/index.js"],"sourcesContent":["var shp = require(\"./shp\"),\n    dbf = require(\"./dbf\");\n\nexports.version = require(\"./package.json\").version;\nexports.read = read;\nexports.reader = reader;\n\nvar readInternal = require(\"./read\")(reader);\n\nfunction read(filename, options, callback) {\n  if (arguments.length < 3) callback = options, options = null;\n  readInternal(filename, options, function(error, header, records) {\n    if (error) return callback(error);\n    callback(null, {\n      type: \"FeatureCollection\",\n      bbox: header.bbox,\n      features: records\n    });\n  });\n}\n\nfunction reader(filename, options) {\n  var convertProperties,\n      convertGeometry,\n      encoding = null,\n      ignoreProperties = false,\n      dbfReader,\n      shpReader;\n\n  if (typeof options === \"string\") options = {encoding: options};\n\n  if (options)\n    \"encoding\" in options && (encoding = options[\"encoding\"]),\n    \"ignore-properties\" in options && (ignoreProperties = !!options[\"ignore-properties\"]);\n\n  if (/\\.shp$/.test(filename)) filename = filename.substring(0, filename.length - 4);\n\n  if (!ignoreProperties) dbfReader = dbf.reader(filename + \".dbf\", encoding);\n  shpReader = shp.reader(filename + \".shp\");\n\n  function readHeader(callback) {\n    dbfReader.readHeader(function(error, header) {\n      if (header === end) error = new Error(\"unexpected EOF\");\n      if (error) return callback(error);\n      convertProperties = new Function(\"d\", \"return {\"\n          + header.fields.map(function(field, i) { return JSON.stringify(field.name) + \":d[\" + i + \"]\"; })\n          + \"};\");\n      readShpHeader(callback);\n    });\n    return this;\n  }\n\n  function readShpHeader(callback) {\n    shpReader.readHeader(function(error, header) {\n      if (header === end) error = new Error(\"unexpected EOF\");\n      if (error) return callback(error);\n      convertGeometry = convertGeometryTypes[header.shapeType];\n      callback(null, {bbox: header.box});\n    });\n    return this;\n  }\n\n  function readRecord(callback) {\n    dbfReader.readRecord(function(error, dbfRecord) {\n      if (dbfRecord === end) return callback(null, end);\n      if (error) return callback(error);\n      shpReader.readRecord(function(error, shpRecord) {\n        if (shpRecord === end) error = new Error(\"unexpected EOF\");\n        if (error) return callback(error);\n        callback(null, {\n          type: \"Feature\",\n          properties: convertProperties(dbfRecord),\n          geometry: shpRecord == null ? null : convertGeometry(shpRecord)\n        });\n      });\n    });\n    return this;\n  }\n\n  function readShpRecord(callback) {\n    shpReader.readRecord(function(error, shpRecord) {\n      if (shpRecord === end) return callback(null, end);\n      if (error) return callback(error);\n      callback(null, {\n        type: \"Feature\",\n        properties: {},\n        geometry: shpRecord == null ? null : convertGeometry(shpRecord)\n      });\n    });\n    return this;\n  }\n\n  function close(callback) {\n    dbfReader.close(function(error) {\n      if (error) return callback(error);\n      closeShp(callback);\n    });\n    return this;\n  }\n\n  function closeShp(callback) {\n    shpReader.close(callback);\n    return this;\n  }\n\n  return dbfReader ? {\n    readHeader: readHeader,\n    readRecord: readRecord,\n    close: close\n  } : {\n    readHeader: readShpHeader,\n    readRecord: readShpRecord,\n    close: closeShp\n  };\n}\n\nvar end = exports.end = shp.end;\n\nvar convertGeometryTypes = {\n  1: convertPoint,\n  3: convertPolyLine,\n  5: convertPolygon,\n  8: convertMultiPoint,\n  11: convertPoint, // PointZ\n  13: convertPolyLine, // PolyLineZ\n  15: convertPolygon, // PolygonZ\n  18: convertMultiPoint // MultiPointZ\n};\n\nfunction readEmptyNextProperties(callback) {\n  callback(null, {});\n}\n\nfunction convertPoint(record) {\n  return {\n    type: \"Point\",\n    coordinates: [record.x, record.y]\n  };\n}\n\nfunction convertPolyLine(record) {\n  return record.parts.length === 1 ? {\n    type: \"LineString\",\n    coordinates: record.points\n  } : {\n    type: \"MultiLineString\",\n    coordinates: record.parts.map(function(i, j) {\n      return record.points.slice(i, record.parts[j + 1]);\n    })\n  };\n}\n\nfunction convertPolygon(record) {\n  var parts = record.parts.map(function(i, j) { return record.points.slice(i, record.parts[j + 1]); }),\n      polygons = [],\n      holes = [];\n\n  parts.forEach(function(part) {\n    if (ringClockwise(part)) polygons.push([part]);\n    else holes.push(part);\n  });\n\n  holes.forEach(function(hole) {\n    var point = hole[0];\n    polygons.some(function(polygon) {\n      if (ringContains(polygon[0], point)) {\n        polygon.push(hole);\n        return true;\n      }\n    }) || polygons.push([hole]);\n  });\n\n  return polygons.length > 1\n      ? {type: \"MultiPolygon\", coordinates: polygons}\n      : {type: \"Polygon\", coordinates: polygons[0]};\n}\n\nfunction convertMultiPoint(record) {\n  return {\n    type: \"MultiPoint\",\n    coordinates: record.points\n  };\n}\n\nfunction ringClockwise(ring) {\n  if ((n = ring.length) < 4) return false;\n  var i = 0,\n      n,\n      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area >= 0;\n}\n\nfunction ringContains(ring, point) {\n  var x = point[0],\n      y = point[1],\n      contains = false;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i], xi = pi[0], yi = pi[1],\n        pj = ring[j], xj = pj[0], yj = pj[1];\n    if (((yi > y) ^ (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) contains = !contains;\n  }\n  return contains;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}