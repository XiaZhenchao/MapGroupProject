{"ast":null,"code":"'use strict';\n\nlet proj4 = require('proj4');\nif (proj4.default) {\n  proj4 = proj4.default;\n}\nconst unzip = require('./unzip');\nconst binaryAjax = require('./binaryajax');\nconst parseShp = require('./parseShp');\nconst parseDbf = require('parsedbf');\nconst Promise = require('lie');\nconst Cache = require('lru-cache');\nconst Buffer = require('buffer').Buffer;\nconst URL = global.URL;\nconst cache = new Cache({\n  max: 20\n});\nfunction toBuffer(b) {\n  if (!b) {\n    throw new Error('forgot to pass buffer');\n  }\n  if (Buffer.isBuffer(b)) {\n    return b;\n  }\n  if (isArrayBuffer(b)) {\n    return Buffer.from(b);\n  }\n  if (isArrayBuffer(b.buffer)) {\n    if (b.BYTES_PER_ELEMENT === 1) {\n      return Buffer.from(b);\n    }\n    return Buffer.from(b.buffer);\n  }\n}\nfunction isArrayBuffer(subject) {\n  return subject instanceof global.ArrayBuffer || Object.prototype.toString.call(subject) === '[object ArrayBuffer]';\n}\nfunction shp(base, whiteList) {\n  if (typeof base === 'string' && cache.has(base)) {\n    return Promise.resolve(cache.get(base));\n  }\n  return shp.getShapefile(base, whiteList).then(function (resp) {\n    if (typeof base === 'string') {\n      cache.set(base, resp);\n    }\n    return resp;\n  });\n}\nshp.combine = function ([shp, dbf]) {\n  const out = {};\n  out.type = 'FeatureCollection';\n  out.features = [];\n  let i = 0;\n  const len = shp.length;\n  if (!dbf) {\n    dbf = [];\n  }\n  while (i < len) {\n    out.features.push({\n      type: 'Feature',\n      geometry: shp[i],\n      properties: dbf[i] || {}\n    });\n    i++;\n  }\n  return out;\n};\nshp.parseZip = async function (buffer, whiteList) {\n  let key;\n  buffer = toBuffer(buffer);\n  const zip = await unzip(buffer);\n  const names = [];\n  whiteList = whiteList || [];\n  for (key in zip) {\n    if (key.indexOf('__MACOSX') !== -1) {\n      continue;\n    }\n    if (key.slice(-3).toLowerCase() === 'shp') {\n      names.push(key.slice(0, -4));\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    } else if (key.slice(-3).toLowerCase() === 'prj') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);\n    } else if (key.slice(-4).toLowerCase() === 'json' || whiteList.indexOf(key.split('.').pop()) > -1) {\n      names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());\n    } else if (key.slice(-3).toLowerCase() === 'dbf' || key.slice(-3).toLowerCase() === 'cpg') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    }\n  }\n  if (!names.length) {\n    throw new Error('no layers founds');\n  }\n  const geojson = names.map(function (name) {\n    let parsed, dbf;\n    const lastDotIdx = name.lastIndexOf('.');\n    if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf('json') > -1) {\n      parsed = JSON.parse(zip[name]);\n      parsed.fileName = name.slice(0, lastDotIdx);\n    } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {\n      parsed = zip[name];\n      parsed.fileName = name;\n    } else {\n      if (zip[name + '.dbf']) {\n        dbf = parseDbf(zip[name + '.dbf'], zip[name + '.cpg']);\n      }\n      parsed = shp.combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), dbf]);\n      parsed.fileName = name;\n    }\n    return parsed;\n  });\n  if (geojson.length === 1) {\n    return geojson[0];\n  } else {\n    return geojson;\n  }\n};\nasync function getZip(base, whiteList) {\n  const a = await binaryAjax(base);\n  return shp.parseZip(a, whiteList);\n}\nconst handleShp = async base => {\n  const args = await Promise.all([binaryAjax(base, 'shp'), binaryAjax(base, 'prj')]);\n  let prj = false;\n  try {\n    if (args[1]) {\n      prj = proj4(args[1]);\n    }\n  } catch (e) {\n    prj = false;\n  }\n  return parseShp(args[0], prj);\n};\nconst handleDbf = async base => {\n  const [dbf, cpg] = await Promise.all([binaryAjax(base, 'dbf'), binaryAjax(base, 'cpg')]);\n  if (!dbf) {\n    return;\n  }\n  return parseDbf(dbf, cpg);\n};\nconst checkSuffix = (base, suffix) => {\n  const url = new URL(base);\n  return url.pathname.slice(-4).toLowerCase() === suffix;\n};\nshp.getShapefile = async function (base, whiteList) {\n  if (typeof base !== 'string') {\n    return shp.parseZip(base);\n  }\n  if (checkSuffix(base, '.zip')) {\n    return getZip(base, whiteList);\n  }\n  const results = await Promise.all([handleShp(base), handleDbf(base)]);\n  return shp.combine(results);\n};\nshp.parseShp = function (shp, prj) {\n  shp = toBuffer(shp);\n  if (Buffer.isBuffer(prj)) {\n    prj = prj.toString();\n  }\n  if (typeof prj === 'string') {\n    try {\n      prj = proj4(prj);\n    } catch (e) {\n      prj = false;\n    }\n  }\n  return parseShp(shp, prj);\n};\nshp.parseDbf = function (dbf, cpg) {\n  dbf = toBuffer(dbf);\n  return parseDbf(dbf, cpg);\n};\nmodule.exports = shp;","map":{"version":3,"names":["proj4","require","default","unzip","binaryAjax","parseShp","parseDbf","Promise","Cache","Buffer","URL","global","cache","max","toBuffer","b","Error","isBuffer","isArrayBuffer","from","buffer","BYTES_PER_ELEMENT","subject","ArrayBuffer","Object","prototype","toString","call","shp","base","whiteList","has","resolve","get","getShapefile","then","resp","set","combine","dbf","out","type","features","i","len","length","push","geometry","properties","parseZip","key","zip","names","indexOf","slice","toLowerCase","split","pop","geojson","map","name","parsed","lastDotIdx","lastIndexOf","JSON","parse","fileName","getZip","a","handleShp","args","all","prj","e","handleDbf","cpg","checkSuffix","suffix","url","pathname","results","module","exports"],"sources":["C:/Users/haosh/desktop/CSE416 projec/MapGroupProject/node_modules/shpjs/lib/index.js"],"sourcesContent":["'use strict';\nlet proj4 = require('proj4');\nif (proj4.default) {\n  proj4 = proj4.default;\n}\nconst unzip = require('./unzip');\nconst binaryAjax = require('./binaryajax');\nconst parseShp = require('./parseShp');\nconst parseDbf = require('parsedbf');\nconst Promise = require('lie');\nconst Cache = require('lru-cache');\nconst Buffer = require('buffer').Buffer;\nconst URL = global.URL;\n\nconst cache = new Cache({\n  max: 20\n});\n\nfunction toBuffer (b) {\n  if (!b) {\n    throw new Error('forgot to pass buffer');\n  }\n  if (Buffer.isBuffer(b)) {\n    return b;\n  }\n  if (isArrayBuffer(b)) {\n    return Buffer.from(b);\n  }\n  if (isArrayBuffer(b.buffer)) {\n    if (b.BYTES_PER_ELEMENT === 1) {\n      return Buffer.from(b);\n    }\n    return Buffer.from(b.buffer);\n  }\n}\n\nfunction isArrayBuffer (subject) {\n  return subject instanceof global.ArrayBuffer || Object.prototype.toString.call(subject) === '[object ArrayBuffer]';\n}\n\nfunction shp (base, whiteList) {\n  if (typeof base === 'string' && cache.has(base)) {\n    return Promise.resolve(cache.get(base));\n  }\n  return shp.getShapefile(base, whiteList).then(function (resp) {\n    if (typeof base === 'string') {\n      cache.set(base, resp);\n    }\n    return resp;\n  });\n}\nshp.combine = function ([shp, dbf]) {\n  const out = {};\n  out.type = 'FeatureCollection';\n  out.features = [];\n  let i = 0;\n  const len = shp.length;\n  if (!dbf) {\n    dbf = [];\n  }\n  while (i < len) {\n    out.features.push({\n      type: 'Feature',\n      geometry: shp[i],\n      properties: dbf[i] || {}\n    });\n    i++;\n  }\n  return out;\n};\nshp.parseZip = async function (buffer, whiteList) {\n  let key;\n  buffer = toBuffer(buffer);\n  const zip = await unzip(buffer);\n  const names = [];\n  whiteList = whiteList || [];\n  for (key in zip) {\n    if (key.indexOf('__MACOSX') !== -1) {\n      continue;\n    }\n    if (key.slice(-3).toLowerCase() === 'shp') {\n      names.push(key.slice(0, -4));\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    } else if (key.slice(-3).toLowerCase() === 'prj') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);\n    } else if (key.slice(-4).toLowerCase() === 'json' || whiteList.indexOf(key.split('.').pop()) > -1) {\n      names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());\n    } else if (key.slice(-3).toLowerCase() === 'dbf' || key.slice(-3).toLowerCase() === 'cpg') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    }\n  }\n  if (!names.length) {\n    throw new Error('no layers founds');\n  }\n  const geojson = names.map(function (name) {\n    let parsed, dbf;\n    const lastDotIdx = name.lastIndexOf('.');\n    if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf('json') > -1) {\n      parsed = JSON.parse(zip[name]);\n      parsed.fileName = name.slice(0, lastDotIdx);\n    } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {\n      parsed = zip[name];\n      parsed.fileName = name;\n    } else {\n      if (zip[name + '.dbf']) {\n        dbf = parseDbf(zip[name + '.dbf'], zip[name + '.cpg']);\n      }\n      parsed = shp.combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), dbf]);\n      parsed.fileName = name;\n    }\n    return parsed;\n  });\n  if (geojson.length === 1) {\n    return geojson[0];\n  } else {\n    return geojson;\n  }\n};\n\nasync function getZip (base, whiteList) {\n  const a = await binaryAjax(base);\n  return shp.parseZip(a, whiteList);\n}\nconst handleShp = async (base) => {\n  const args = await Promise.all([\n    binaryAjax(base, 'shp'),\n    binaryAjax(base, 'prj')\n  ]);\n  let prj = false;\n  try {\n    if (args[1]) {\n      prj = proj4(args[1]);\n    }\n  } catch (e) {\n    prj = false;\n  }\n  return parseShp(args[0], prj);\n};\nconst handleDbf = async (base) => {\n  const [dbf, cpg] = await Promise.all([\n    binaryAjax(base, 'dbf'),\n    binaryAjax(base, 'cpg')\n  ]);\n  if (!dbf) {\n    return;\n  }\n  return parseDbf(dbf, cpg);\n};\nconst checkSuffix = (base, suffix) => {\n  const url = new URL(base);\n  return url.pathname.slice(-4).toLowerCase() === suffix;\n};\nshp.getShapefile = async function (base, whiteList) {\n  if (typeof base !== 'string') {\n    return shp.parseZip(base);\n  }\n  if (checkSuffix(base, '.zip')) {\n    return getZip(base, whiteList);\n  }\n  const results = await Promise.all([\n    handleShp(base),\n    handleDbf(base)\n  ]);\n  return shp.combine(results);\n};\nshp.parseShp = function (shp, prj) {\n  shp = toBuffer(shp);\n  if (Buffer.isBuffer(prj)) {\n    prj = prj.toString();\n  }\n  if (typeof prj === 'string') {\n    try {\n      prj = proj4(prj);\n    } catch (e) {\n      prj = false;\n    }\n  }\n  return parseShp(shp, prj);\n};\nshp.parseDbf = function (dbf, cpg) {\n  dbf = toBuffer(dbf);\n  return parseDbf(dbf, cpg);\n};\nmodule.exports = shp;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}