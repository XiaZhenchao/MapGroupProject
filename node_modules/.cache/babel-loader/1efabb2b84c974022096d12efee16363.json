{"ast":null,"code":"import { PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_NODATUM, R2D, SRS_WGS84_ESQUARED, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR } from './constants/values';\nimport { geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums } from './datumUtils';\nimport adjust_lon from \"./common/adjust_lon\";\nfunction checkParams(type) {\n  return type === PJD_3PARAM || type === PJD_7PARAM;\n}\nexport default function (source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n  return point;\n}\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n  var input = {\n    x: -point.x,\n    y: point.y\n  };\n  var output = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    onlyMandatoryGrids = grid.mandatory;\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n      continue;\n    }\n    var subgrid = grid.grid.subgrids[0];\n    // skip tables that don't match our point at all\n    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n    var minX = subgrid.ll[0] - epsilon;\n    var minY = subgrid.ll[1] - epsilon;\n    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {\n      continue;\n    }\n    output = applySubgridShift(input, inverse, subgrid);\n    if (!isNaN(output.x)) {\n      break;\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\" + -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  if (isNaN(pin.x)) {\n    return val;\n  }\n  var tb = {\n    x: pin.x,\n    y: pin.y\n  };\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9,\n      tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n      dif = {\n        x: tb.x - (del.x + t.x),\n        y: tb.y - (del.y + t.y)\n      };\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\nfunction nadInterpolate(pin, ct) {\n  var t = {\n    x: pin.x / ct.del[0],\n    y: pin.y / ct.del[1]\n  };\n  var indx = {\n    x: Math.floor(t.x),\n    y: Math.floor(t.y)\n  };\n  var frct = {\n    x: t.x - 1.0 * indx.x,\n    y: t.y - 1.0 * indx.y\n  };\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = indx.y * ct.lim[0] + indx.x;\n  var f00 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx++;\n  var f10 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx += ct.lim[0];\n  var f11 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx--;\n  var f01 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  var m11 = frct.x * frct.y,\n    m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y),\n    m01 = (1.0 - frct.x) * frct.y;\n  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;\n  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;\n  return val;\n}","map":{"version":3,"names":["PJD_3PARAM","PJD_7PARAM","PJD_GRIDSHIFT","PJD_NODATUM","R2D","SRS_WGS84_ESQUARED","SRS_WGS84_SEMIMAJOR","SRS_WGS84_SEMIMINOR","geodeticToGeocentric","geocentricToGeodetic","geocentricToWgs84","geocentricFromWgs84","compareDatums","adjust_lon","checkParams","type","source","dest","point","datum_type","source_a","a","source_es","es","gridShiftCode","applyGridShift","undefined","dest_a","dest_b","b","dest_es","datum_params","destGridShiftResult","inverse","grids","length","console","log","input","x","y","output","Number","NaN","onlyMandatoryGrids","attemptedGrids","i","grid","push","name","isNull","mandatory","subgrid","subgrids","epsilon","Math","abs","del","minX","ll","minY","maxX","lim","maxY","applySubgridShift","isNaN","pin","ct","val","tb","PI","t","nadInterpolate","tol","dif","indx","floor","frct","inx","f00","cvs","f10","f11","f01","m11","m10","m00","m01"],"sources":["C:/Users/haosh/desktop/CSE416 projec/MapGroupProject/node_modules/proj4/lib/datum_transform.js"],"sourcesContent":["import {\n  PJD_3PARAM,\n  PJD_7PARAM,\n  PJD_GRIDSHIFT,\n  PJD_NODATUM,\n  R2D,\n  SRS_WGS84_ESQUARED,\n  SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR\n} from './constants/values';\n\nimport {geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums} from './datumUtils';\nimport adjust_lon from \"./common/adjust_lon\";\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n\n  return point;\n}\n\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n  var input = {x: -point.x, y: point.y};\n  var output = {x: Number.NaN, y: Number.NaN};\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    onlyMandatoryGrids = grid.mandatory;\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n      continue;\n    }\n    var subgrid = grid.grid.subgrids[0];\n    // skip tables that don't match our point at all\n    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n    var minX = subgrid.ll[0] - epsilon;\n    var minY = subgrid.ll[1] - epsilon;\n    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {\n      continue;\n    }\n    output = applySubgridShift(input, inverse, subgrid);\n    if (!isNaN(output.x)) {\n      break;\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\"+\n      -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\n\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {x: Number.NaN, y: Number.NaN};\n  if (isNaN(pin.x)) { return val; }\n  var tb = {x: pin.x, y: pin.y};\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9, tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\n\nfunction nadInterpolate(pin, ct) {\n  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};\n  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};\n  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};\n  var val= {x: Number.NaN, y: Number.NaN};\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = (indx.y * ct.lim[0]) + indx.x;\n  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx++;\n  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx += ct.lim[0];\n  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx--;\n  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;\n  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);\n  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);\n  return val;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}