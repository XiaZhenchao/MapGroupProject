{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.topojson = global.topojson || {});\n})(this, function (exports) {\n  'use strict';\n\n  function noop() {}\n  function transformAbsolute(transform) {\n    if (!transform) return noop;\n    var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n    return function (point, i) {\n      if (!i) x0 = y0 = 0;\n      point[0] = (x0 += point[0]) * kx + dx;\n      point[1] = (y0 += point[1]) * ky + dy;\n    };\n  }\n  function transformRelative(transform) {\n    if (!transform) return noop;\n    var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n    return function (point, i) {\n      if (!i) x0 = y0 = 0;\n      var x1 = Math.round((point[0] - dx) / kx),\n        y1 = Math.round((point[1] - dy) / ky);\n      point[0] = x1 - x0;\n      point[1] = y1 - y0;\n      x0 = x1;\n      y0 = y1;\n    };\n  }\n  function reverse(array, n) {\n    var t,\n      j = array.length,\n      i = j - n;\n    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n  }\n  function bisect(a, x) {\n    var lo = 0,\n      hi = a.length;\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (a[mid] < x) lo = mid + 1;else hi = mid;\n    }\n    return lo;\n  }\n  function feature(topology, o) {\n    return o.type === \"GeometryCollection\" ? {\n      type: \"FeatureCollection\",\n      features: o.geometries.map(function (o) {\n        return feature$1(topology, o);\n      })\n    } : feature$1(topology, o);\n  }\n  function feature$1(topology, o) {\n    var f = {\n      type: \"Feature\",\n      id: o.id,\n      properties: o.properties || {},\n      geometry: object(topology, o)\n    };\n    if (o.id == null) delete f.id;\n    return f;\n  }\n  function object(topology, o) {\n    var absolute = transformAbsolute(topology.transform),\n      arcs = topology.arcs;\n    function arc(i, points) {\n      if (points.length) points.pop();\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {\n        points.push(p = a[k].slice());\n        absolute(p, k);\n      }\n      if (i < 0) reverse(points, n);\n    }\n    function point(p) {\n      p = p.slice();\n      absolute(p, 0);\n      return p;\n    }\n    function line(arcs) {\n      var points = [];\n      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n      if (points.length < 2) points.push(points[0].slice());\n      return points;\n    }\n    function ring(arcs) {\n      var points = line(arcs);\n      while (points.length < 4) points.push(points[0].slice());\n      return points;\n    }\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n    function geometry(o) {\n      var t = o.type;\n      return t === \"GeometryCollection\" ? {\n        type: t,\n        geometries: o.geometries.map(geometry)\n      } : t in geometryType ? {\n        type: t,\n        coordinates: geometryType[t](o)\n      } : null;\n    }\n    var geometryType = {\n      Point: function (o) {\n        return point(o.coordinates);\n      },\n      MultiPoint: function (o) {\n        return o.coordinates.map(point);\n      },\n      LineString: function (o) {\n        return line(o.arcs);\n      },\n      MultiLineString: function (o) {\n        return o.arcs.map(line);\n      },\n      Polygon: function (o) {\n        return polygon(o.arcs);\n      },\n      MultiPolygon: function (o) {\n        return o.arcs.map(polygon);\n      }\n    };\n    return geometry(o);\n  }\n  function stitchArcs(topology, arcs) {\n    var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n    // Stitch empty arcs first, since they may be subsumed by other arcs.\n    arcs.forEach(function (i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n        t;\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n    arcs.forEach(function (i) {\n      var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f,\n        g;\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n        p0 = arc[0],\n        p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {\n        p1[0] += dp[0], p1[1] += dp[1];\n      });else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function (i) {\n          stitchedArcs[i < 0 ? ~i : i] = 1;\n        });\n        fragments.push(f);\n      }\n    }\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function (i) {\n      if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);\n    });\n    return fragments;\n  }\n  function mesh(topology) {\n    return object(topology, meshArcs.apply(this, arguments));\n  }\n  function meshArcs(topology, o, filter) {\n    var arcs = [];\n    function arc(i) {\n      var j = i < 0 ? ~i : i;\n      (geomsByArc[j] || (geomsByArc[j] = [])).push({\n        i: i,\n        g: geom\n      });\n    }\n    function line(arcs) {\n      arcs.forEach(arc);\n    }\n    function polygon(arcs) {\n      arcs.forEach(line);\n    }\n    function geometry(o) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(geometry);else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);\n    }\n    if (arguments.length > 1) {\n      var geomsByArc = [],\n        geom;\n      var geometryType = {\n        LineString: line,\n        MultiLineString: polygon,\n        Polygon: polygon,\n        MultiPolygon: function (arcs) {\n          arcs.forEach(polygon);\n        }\n      };\n      geometry(o);\n      geomsByArc.forEach(arguments.length < 3 ? function (geoms) {\n        arcs.push(geoms[0].i);\n      } : function (geoms) {\n        if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);\n      });\n    } else {\n      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);\n    }\n    return {\n      type: \"MultiLineString\",\n      arcs: stitchArcs(topology, arcs)\n    };\n  }\n  function cartesianTriangleArea(triangle) {\n    var a = triangle[0],\n      b = triangle[1],\n      c = triangle[2];\n    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));\n  }\n  function ring(ring) {\n    var i = -1,\n      n = ring.length,\n      a,\n      b = ring[n - 1],\n      area = 0;\n    while (++i < n) {\n      a = b;\n      b = ring[i];\n      area += a[0] * b[1] - a[1] * b[0];\n    }\n    return area / 2;\n  }\n  function merge(topology) {\n    return object(topology, mergeArcs.apply(this, arguments));\n  }\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n      polygons = [],\n      components = [];\n    objects.forEach(function (o) {\n      if (o.type === \"Polygon\") register(o.arcs);else if (o.type === \"MultiPolygon\") o.arcs.forEach(register);\n    });\n    function register(polygon) {\n      polygon.forEach(function (ring$$) {\n        ring$$.forEach(function (arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n    function area(ring$$) {\n      return Math.abs(ring(object(topology, {\n        type: \"Polygon\",\n        arcs: [ring$$]\n      }).coordinates[0]));\n    }\n    polygons.forEach(function (polygon) {\n      if (!polygon._) {\n        var component = [],\n          neighbors = [polygon];\n        polygon._ = 1;\n        components.push(component);\n        while (polygon = neighbors.pop()) {\n          component.push(polygon);\n          polygon.forEach(function (ring$$) {\n            ring$$.forEach(function (arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n    polygons.forEach(function (polygon) {\n      delete polygon._;\n    });\n    return {\n      type: \"MultiPolygon\",\n      arcs: components.map(function (polygons) {\n        var arcs = [],\n          n;\n\n        // Extract the exterior (unique) arcs.\n        polygons.forEach(function (polygon) {\n          polygon.forEach(function (ring$$) {\n            ring$$.forEach(function (arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        });\n\n        // Stitch the arcs into one or more rings.\n        arcs = stitchArcs(topology, arcs);\n\n        // If more than one ring is returned,\n        // at most one of these rings can be the exterior;\n        // choose the one with the greatest absolute area.\n        if ((n = arcs.length) > 1) {\n          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n            if ((ki = area(arcs[i])) > k) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n            }\n          }\n        }\n        return arcs;\n      })\n    };\n  }\n  function neighbors(objects) {\n    var indexesByArc = {},\n      // arc index -> array of object indexes\n      neighbors = objects.map(function () {\n        return [];\n      });\n    function line(arcs, i) {\n      arcs.forEach(function (a) {\n        if (a < 0) a = ~a;\n        var o = indexesByArc[a];\n        if (o) o.push(i);else indexesByArc[a] = [i];\n      });\n    }\n    function polygon(arcs, i) {\n      arcs.forEach(function (arc) {\n        line(arc, i);\n      });\n    }\n    function geometry(o, i) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(function (o) {\n        geometry(o, i);\n      });else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n    }\n    var geometryType = {\n      LineString: line,\n      MultiLineString: polygon,\n      Polygon: polygon,\n      MultiPolygon: function (arcs, i) {\n        arcs.forEach(function (arc) {\n          polygon(arc, i);\n        });\n      }\n    };\n    objects.forEach(geometry);\n    for (var i in indexesByArc) {\n      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n        for (var k = j + 1; k < m; ++k) {\n          var ij = indexes[j],\n            ik = indexes[k],\n            n;\n          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n        }\n      }\n    }\n    return neighbors;\n  }\n  function compareArea(a, b) {\n    return a[1][2] - b[1][2];\n  }\n  function minAreaHeap() {\n    var heap = {},\n      array = [],\n      size = 0;\n    heap.push = function (object) {\n      up(array[object._ = size] = object, size++);\n      return size;\n    };\n    heap.pop = function () {\n      if (size <= 0) return;\n      var removed = array[0],\n        object;\n      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n      return removed;\n    };\n    heap.remove = function (removed) {\n      var i = removed._,\n        object;\n      if (array[i] !== removed) return; // invalid request\n      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n      return i;\n    };\n    function up(object, i) {\n      while (i > 0) {\n        var j = (i + 1 >> 1) - 1,\n          parent = array[j];\n        if (compareArea(object, parent) >= 0) break;\n        array[parent._ = i] = parent;\n        array[object._ = i = j] = object;\n      }\n    }\n    function down(object, i) {\n      while (true) {\n        var r = i + 1 << 1,\n          l = r - 1,\n          j = i,\n          child = array[j];\n        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];\n        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];\n        if (j === i) break;\n        array[child._ = i] = child;\n        array[object._ = i = j] = object;\n      }\n    }\n    return heap;\n  }\n  function presimplify(topology, triangleArea) {\n    var absolute = transformAbsolute(topology.transform),\n      relative = transformRelative(topology.transform),\n      heap = minAreaHeap();\n    if (!triangleArea) triangleArea = cartesianTriangleArea;\n    topology.arcs.forEach(function (arc) {\n      var triangles = [],\n        maxArea = 0,\n        triangle,\n        i,\n        n,\n        p;\n\n      // To store each point’s effective area, we create a new array rather than\n      // extending the passed-in point to workaround a Chrome/V8 bug (getting\n      // stuck in smi mode). For midpoints, the initial effective area of\n      // Infinity will be computed in the next step.\n      for (i = 0, n = arc.length; i < n; ++i) {\n        p = arc[i];\n        absolute(arc[i] = [p[0], p[1], Infinity], i);\n      }\n      for (i = 1, n = arc.length - 1; i < n; ++i) {\n        triangle = arc.slice(i - 1, i + 2);\n        triangle[1][2] = triangleArea(triangle);\n        triangles.push(triangle);\n        heap.push(triangle);\n      }\n      for (i = 0, n = triangles.length; i < n; ++i) {\n        triangle = triangles[i];\n        triangle.previous = triangles[i - 1];\n        triangle.next = triangles[i + 1];\n      }\n      while (triangle = heap.pop()) {\n        var previous = triangle.previous,\n          next = triangle.next;\n\n        // If the area of the current point is less than that of the previous point\n        // to be eliminated, use the latter's area instead. This ensures that the\n        // current point cannot be eliminated without eliminating previously-\n        // eliminated points.\n        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;else maxArea = triangle[1][2];\n        if (previous) {\n          previous.next = next;\n          previous[2] = triangle[2];\n          update(previous);\n        }\n        if (next) {\n          next.previous = previous;\n          next[0] = triangle[0];\n          update(next);\n        }\n      }\n      arc.forEach(relative);\n    });\n    function update(triangle) {\n      heap.remove(triangle);\n      triangle[1][2] = triangleArea(triangle);\n      heap.push(triangle);\n    }\n    return topology;\n  }\n  var version = \"1.6.26\";\n  exports.version = version;\n  exports.mesh = mesh;\n  exports.meshArcs = meshArcs;\n  exports.merge = merge;\n  exports.mergeArcs = mergeArcs;\n  exports.feature = feature;\n  exports.neighbors = neighbors;\n  exports.presimplify = presimplify;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","topojson","noop","transformAbsolute","transform","x0","y0","kx","scale","ky","dx","translate","dy","point","i","transformRelative","x1","Math","round","y1","reverse","array","n","t","j","length","bisect","a","x","lo","hi","mid","feature","topology","o","type","features","geometries","map","feature$1","f","id","properties","geometry","object","absolute","arcs","arc","points","pop","k","p","push","slice","line","ring","polygon","geometryType","coordinates","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","stitchArcs","stitchedArcs","fragmentByStart","fragmentByEnd","fragments","emptyIndex","forEach","e","ends","start","end","g","fg","concat","unshift","gf","p0","p1","dp","flush","mesh","meshArcs","apply","arguments","filter","geomsByArc","geom","geoms","cartesianTriangleArea","triangle","b","c","abs","area","merge","mergeArcs","objects","polygonsByArc","polygons","components","register","ring$$","_","component","neighbors","ki","indexesByArc","indexes","m","ij","ik","splice","compareArea","minAreaHeap","heap","size","up","removed","down","remove","parent","r","l","child","presimplify","triangleArea","relative","triangles","maxArea","Infinity","previous","next","update","version"],"sources":["/Users/yongerfan/Desktop/GroupProject/MapGroupProject/node_modules/topojson/build/topojson.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.topojson = global.topojson || {})));\n}(this, function (exports) { 'use strict';\n\n  function noop() {}\n\n  function transformAbsolute(transform) {\n    if (!transform) return noop;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function(point, i) {\n      if (!i) x0 = y0 = 0;\n      point[0] = (x0 += point[0]) * kx + dx;\n      point[1] = (y0 += point[1]) * ky + dy;\n    };\n  }\n\n  function transformRelative(transform) {\n    if (!transform) return noop;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function(point, i) {\n      if (!i) x0 = y0 = 0;\n      var x1 = Math.round((point[0] - dx) / kx),\n          y1 = Math.round((point[1] - dy) / ky);\n      point[0] = x1 - x0;\n      point[1] = y1 - y0;\n      x0 = x1;\n      y0 = y1;\n    };\n  }\n\n  function reverse(array, n) {\n    var t, j = array.length, i = j - n;\n    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n  }\n\n  function bisect(a, x) {\n    var lo = 0, hi = a.length;\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (a[mid] < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function feature(topology, o) {\n    return o.type === \"GeometryCollection\" ? {\n      type: \"FeatureCollection\",\n      features: o.geometries.map(function(o) { return feature$1(topology, o); })\n    } : feature$1(topology, o);\n  }\n\n  function feature$1(topology, o) {\n    var f = {\n      type: \"Feature\",\n      id: o.id,\n      properties: o.properties || {},\n      geometry: object(topology, o)\n    };\n    if (o.id == null) delete f.id;\n    return f;\n  }\n\n  function object(topology, o) {\n    var absolute = transformAbsolute(topology.transform),\n        arcs = topology.arcs;\n\n    function arc(i, points) {\n      if (points.length) points.pop();\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {\n        points.push(p = a[k].slice());\n        absolute(p, k);\n      }\n      if (i < 0) reverse(points, n);\n    }\n\n    function point(p) {\n      p = p.slice();\n      absolute(p, 0);\n      return p;\n    }\n\n    function line(arcs) {\n      var points = [];\n      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n      if (points.length < 2) points.push(points[0].slice());\n      return points;\n    }\n\n    function ring(arcs) {\n      var points = line(arcs);\n      while (points.length < 4) points.push(points[0].slice());\n      return points;\n    }\n\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n\n    function geometry(o) {\n      var t = o.type;\n      return t === \"GeometryCollection\" ? {type: t, geometries: o.geometries.map(geometry)}\n          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}\n          : null;\n    }\n\n    var geometryType = {\n      Point: function(o) { return point(o.coordinates); },\n      MultiPoint: function(o) { return o.coordinates.map(point); },\n      LineString: function(o) { return line(o.arcs); },\n      MultiLineString: function(o) { return o.arcs.map(line); },\n      Polygon: function(o) { return polygon(o.arcs); },\n      MultiPolygon: function(o) { return o.arcs.map(polygon); }\n    };\n\n    return geometry(o);\n  }\n\n  function stitchArcs(topology, arcs) {\n    var stitchedArcs = {},\n        fragmentByStart = {},\n        fragmentByEnd = {},\n        fragments = [],\n        emptyIndex = -1;\n\n    // Stitch empty arcs first, since they may be subsumed by other arcs.\n    arcs.forEach(function(i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i], t;\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n\n    arcs.forEach(function(i) {\n      var e = ends(i),\n          start = e[0],\n          end = e[1],\n          f, g;\n\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n      else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n        fragments.push(f);\n      }\n    }\n\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n    return fragments;\n  }\n\n  function mesh(topology) {\n    return object(topology, meshArcs.apply(this, arguments));\n  }\n\n  function meshArcs(topology, o, filter) {\n    var arcs = [];\n\n    function arc(i) {\n      var j = i < 0 ? ~i : i;\n      (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n    }\n\n    function line(arcs) {\n      arcs.forEach(arc);\n    }\n\n    function polygon(arcs) {\n      arcs.forEach(line);\n    }\n\n    function geometry(o) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(geometry);\n      else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);\n    }\n\n    if (arguments.length > 1) {\n      var geomsByArc = [],\n          geom;\n\n      var geometryType = {\n        LineString: line,\n        MultiLineString: polygon,\n        Polygon: polygon,\n        MultiPolygon: function(arcs) { arcs.forEach(polygon); }\n      };\n\n      geometry(o);\n\n      geomsByArc.forEach(arguments.length < 3\n          ? function(geoms) { arcs.push(geoms[0].i); }\n          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n    } else {\n      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);\n    }\n\n    return {type: \"MultiLineString\", arcs: stitchArcs(topology, arcs)};\n  }\n\n  function cartesianTriangleArea(triangle) {\n    var a = triangle[0], b = triangle[1], c = triangle[2];\n    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));\n  }\n\n  function ring(ring) {\n    var i = -1,\n        n = ring.length,\n        a,\n        b = ring[n - 1],\n        area = 0;\n\n    while (++i < n) {\n      a = b;\n      b = ring[i];\n      area += a[0] * b[1] - a[1] * b[0];\n    }\n\n    return area / 2;\n  }\n\n  function merge(topology) {\n    return object(topology, mergeArcs.apply(this, arguments));\n  }\n\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n        polygons = [],\n        components = [];\n\n    objects.forEach(function(o) {\n      if (o.type === \"Polygon\") register(o.arcs);\n      else if (o.type === \"MultiPolygon\") o.arcs.forEach(register);\n    });\n\n    function register(polygon) {\n      polygon.forEach(function(ring$$) {\n        ring$$.forEach(function(arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n\n    function area(ring$$) {\n      return Math.abs(ring(object(topology, {type: \"Polygon\", arcs: [ring$$]}).coordinates[0]));\n    }\n\n    polygons.forEach(function(polygon) {\n      if (!polygon._) {\n        var component = [],\n            neighbors = [polygon];\n        polygon._ = 1;\n        components.push(component);\n        while (polygon = neighbors.pop()) {\n          component.push(polygon);\n          polygon.forEach(function(ring$$) {\n            ring$$.forEach(function(arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n\n    polygons.forEach(function(polygon) {\n      delete polygon._;\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      arcs: components.map(function(polygons) {\n        var arcs = [], n;\n\n        // Extract the exterior (unique) arcs.\n        polygons.forEach(function(polygon) {\n          polygon.forEach(function(ring$$) {\n            ring$$.forEach(function(arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        });\n\n        // Stitch the arcs into one or more rings.\n        arcs = stitchArcs(topology, arcs);\n\n        // If more than one ring is returned,\n        // at most one of these rings can be the exterior;\n        // choose the one with the greatest absolute area.\n        if ((n = arcs.length) > 1) {\n          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n            if ((ki = area(arcs[i])) > k) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n            }\n          }\n        }\n\n        return arcs;\n      })\n    };\n  }\n\n  function neighbors(objects) {\n    var indexesByArc = {}, // arc index -> array of object indexes\n        neighbors = objects.map(function() { return []; });\n\n    function line(arcs, i) {\n      arcs.forEach(function(a) {\n        if (a < 0) a = ~a;\n        var o = indexesByArc[a];\n        if (o) o.push(i);\n        else indexesByArc[a] = [i];\n      });\n    }\n\n    function polygon(arcs, i) {\n      arcs.forEach(function(arc) { line(arc, i); });\n    }\n\n    function geometry(o, i) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n    }\n\n    var geometryType = {\n      LineString: line,\n      MultiLineString: polygon,\n      Polygon: polygon,\n      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n    };\n\n    objects.forEach(geometry);\n\n    for (var i in indexesByArc) {\n      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n        for (var k = j + 1; k < m; ++k) {\n          var ij = indexes[j], ik = indexes[k], n;\n          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n        }\n      }\n    }\n\n    return neighbors;\n  }\n\n  function compareArea(a, b) {\n    return a[1][2] - b[1][2];\n  }\n\n  function minAreaHeap() {\n    var heap = {},\n        array = [],\n        size = 0;\n\n    heap.push = function(object) {\n      up(array[object._ = size] = object, size++);\n      return size;\n    };\n\n    heap.pop = function() {\n      if (size <= 0) return;\n      var removed = array[0], object;\n      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n      return removed;\n    };\n\n    heap.remove = function(removed) {\n      var i = removed._, object;\n      if (array[i] !== removed) return; // invalid request\n      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n      return i;\n    };\n\n    function up(object, i) {\n      while (i > 0) {\n        var j = ((i + 1) >> 1) - 1,\n            parent = array[j];\n        if (compareArea(object, parent) >= 0) break;\n        array[parent._ = i] = parent;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    function down(object, i) {\n      while (true) {\n        var r = (i + 1) << 1,\n            l = r - 1,\n            j = i,\n            child = array[j];\n        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];\n        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];\n        if (j === i) break;\n        array[child._ = i] = child;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    return heap;\n  }\n\n  function presimplify(topology, triangleArea) {\n    var absolute = transformAbsolute(topology.transform),\n        relative = transformRelative(topology.transform),\n        heap = minAreaHeap();\n\n    if (!triangleArea) triangleArea = cartesianTriangleArea;\n\n    topology.arcs.forEach(function(arc) {\n      var triangles = [],\n          maxArea = 0,\n          triangle,\n          i,\n          n,\n          p;\n\n      // To store each point’s effective area, we create a new array rather than\n      // extending the passed-in point to workaround a Chrome/V8 bug (getting\n      // stuck in smi mode). For midpoints, the initial effective area of\n      // Infinity will be computed in the next step.\n      for (i = 0, n = arc.length; i < n; ++i) {\n        p = arc[i];\n        absolute(arc[i] = [p[0], p[1], Infinity], i);\n      }\n\n      for (i = 1, n = arc.length - 1; i < n; ++i) {\n        triangle = arc.slice(i - 1, i + 2);\n        triangle[1][2] = triangleArea(triangle);\n        triangles.push(triangle);\n        heap.push(triangle);\n      }\n\n      for (i = 0, n = triangles.length; i < n; ++i) {\n        triangle = triangles[i];\n        triangle.previous = triangles[i - 1];\n        triangle.next = triangles[i + 1];\n      }\n\n      while (triangle = heap.pop()) {\n        var previous = triangle.previous,\n            next = triangle.next;\n\n        // If the area of the current point is less than that of the previous point\n        // to be eliminated, use the latter's area instead. This ensures that the\n        // current point cannot be eliminated without eliminating previously-\n        // eliminated points.\n        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;\n        else maxArea = triangle[1][2];\n\n        if (previous) {\n          previous.next = next;\n          previous[2] = triangle[2];\n          update(previous);\n        }\n\n        if (next) {\n          next.previous = previous;\n          next[0] = triangle[0];\n          update(next);\n        }\n      }\n\n      arc.forEach(relative);\n    });\n\n    function update(triangle) {\n      heap.remove(triangle);\n      triangle[1][2] = triangleArea(triangle);\n      heap.push(triangle);\n    }\n\n    return topology;\n  }\n\n  var version = \"1.6.26\";\n\n  exports.version = version;\n  exports.mesh = mesh;\n  exports.meshArcs = meshArcs;\n  exports.merge = merge;\n  exports.mergeArcs = mergeArcs;\n  exports.feature = feature;\n  exports.neighbors = neighbors;\n  exports.presimplify = presimplify;\n\n}));"],"mappings":"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"},"metadata":{},"sourceType":"script"}